// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_console_service_account_v1

import (
	"context"
	"fmt"
	"github.com/conduktor/terraform-provider-conduktor/internal/schema/validation"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func ConsoleServiceAccountV1ResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"app_instance": schema.StringAttribute{
				Optional:            true,
				Description:         "Reference to the application instance this service account is associated with",
				MarkdownDescription: "Reference to the application instance this service account is associated with",
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^[0-9a-z\\_\\-]+$"), ""),
				},
			},
			"cluster": schema.StringAttribute{
				Required:            true,
				Description:         "Valid Kafka Cluster name linked with the Service Account",
				MarkdownDescription: "Valid Kafka Cluster name linked with the Service Account",
			},
			"labels": schema.MapAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "Custom labels for the service account",
				MarkdownDescription: "Custom labels for the service account",
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "Service Account name, must be unique, acts as an ID for import",
				MarkdownDescription: "Service Account name, must be unique, acts as an ID for import",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^[0-9a-z\\_\\-]+$"), ""),
				},
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"authorization": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"aiven": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"acls": schema.SetNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Required:            true,
													Description:         "Aiven resource name",
													MarkdownDescription: "Aiven resource name",
												},
												"permission": schema.StringAttribute{
													Required:            true,
													Description:         "Aiven resource permission. Valid values are: admin, read, readwrite, schema_registry_read, schema_registry_write, write",
													MarkdownDescription: "Aiven resource permission. Valid values are: admin, read, readwrite, schema_registry_read, schema_registry_write, write",
													Validators: []validator.String{
														stringvalidator.OneOf(validation.ValidServiceAccountAivenPermission...),
													},
												},
												"resource_type": schema.StringAttribute{
													Required:            true,
													Description:         "Aiven resource type. Valid values are: SCHEMA, TOPIC",
													MarkdownDescription: "Aiven resource type. Valid values are: SCHEMA, TOPIC",
													Validators: []validator.String{
														stringvalidator.OneOf(validation.ValidServiceAccountAivenResourceType...),
													},
												},
											},
											CustomType: AivenAclsType{
												ObjectType: types.ObjectType{
													AttrTypes: AivenAclsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Required:            true,
										Description:         "Set of the Aiven ACLs to apply on the service account",
										MarkdownDescription: "Set of the Aiven ACLs to apply on the service account",
									},
								},
								CustomType: AivenType{
									ObjectType: types.ObjectType{
										AttrTypes: AivenValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Aiven type authorization configuration",
								MarkdownDescription: "Aiven type authorization configuration",
							},
							"kafka": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"acls": schema.SetNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"connect_cluster": schema.StringAttribute{
													Optional:            true,
													Description:         "Valid Kafka Connect Cluster refrence",
													MarkdownDescription: "Valid Kafka Connect Cluster refrence",
												},
												"host": schema.StringAttribute{
													Optional:            true,
													Description:         "Host of the Kafka cluster. If not set it will default to '*'",
													MarkdownDescription: "Host of the Kafka cluster. If not set it will default to '*'",
												},
												"name": schema.StringAttribute{
													Required:            true,
													Description:         "Kafka resource name",
													MarkdownDescription: "Kafka resource name",
												},
												"operations": schema.SetAttribute{
													ElementType:         types.StringType,
													Required:            true,
													Description:         "Set of all operations to apply on the resource. Valid values are: All, Alter, AlterConfigs, ClusterAction, Create, CreateTokens, Delete, Describe, DescribeConfigs, DescribeTokens, IdempotentWrite, Read, Unknown, Write",
													MarkdownDescription: "Set of all operations to apply on the resource. Valid values are: All, Alter, AlterConfigs, ClusterAction, Create, CreateTokens, Delete, Describe, DescribeConfigs, DescribeTokens, IdempotentWrite, Read, Unknown, Write",
													Validators: []validator.Set{
														setvalidator.ValueStringsAre(stringvalidator.OneOf(validation.ValidServiceAccountKafkaOperations...)),
													},
												},
												"pattern_type": schema.StringAttribute{
													Required:            true,
													Description:         "Kafka resource pattern type. Valid values are: LITERAL, PREFIXED",
													MarkdownDescription: "Kafka resource pattern type. Valid values are: LITERAL, PREFIXED",
													Validators: []validator.String{
														stringvalidator.OneOf(validation.ValidServiceAccountKafkaPatternType...),
													},
												},
												"permission": schema.StringAttribute{
													Optional:            true,
													Description:         "Permission Type for Access Control Entry. Valid values are: Deny, Allow. If not set it will default to Allow",
													MarkdownDescription: "Permission Type for Access Control Entry. Valid values are: Deny, Allow. If not set it will default to Allow",
													Validators: []validator.String{
														stringvalidator.OneOf(validation.ValidServiceAccountKafkaPermission...),
													},
												},
												"type": schema.StringAttribute{
													Required:            true,
													Description:         "Kafka resource type. Valid values are: CLUSTER, CONSUMER_GROUP, DELEGATION_TOKEN, TOPIC, TRANSACTIONAL_ID, UNKNOWN, USER",
													MarkdownDescription: "Kafka resource type. Valid values are: CLUSTER, CONSUMER_GROUP, DELEGATION_TOKEN, TOPIC, TRANSACTIONAL_ID, UNKNOWN, USER",
													Validators: []validator.String{
														stringvalidator.OneOf(validation.ValidServiceAccountKafkaType...),
													},
												},
											},
											CustomType: KafkaAclsType{
												ObjectType: types.ObjectType{
													AttrTypes: KafkaAclsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Required:            true,
										Description:         "Set of the Kafka ACLs to apply on the service account",
										MarkdownDescription: "Set of the Kafka ACLs to apply on the service account",
									},
								},
								CustomType: KafkaType{
									ObjectType: types.ObjectType{
										AttrTypes: KafkaValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Kafka type authorization configuration",
								MarkdownDescription: "Kafka type authorization configuration",
							},
						},
						CustomType: AuthorizationType{
							ObjectType: types.ObjectType{
								AttrTypes: AuthorizationValue{}.AttributeTypes(ctx),
							},
						},
						Required:            true,
						Description:         "Service Account authorization. One of `aiven`, `kafka`",
						MarkdownDescription: "Service Account authorization. One of `aiven`, `kafka`",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "Service Accoount specification",
				MarkdownDescription: "Service Accoount specification",
			},
		},
	}
}

type ConsoleServiceAccountV1Model struct {
	AppInstance types.String `tfsdk:"app_instance"`
	Cluster     types.String `tfsdk:"cluster"`
	Labels      types.Map    `tfsdk:"labels"`
	Name        types.String `tfsdk:"name"`
	Spec        SpecValue    `tfsdk:"spec"`
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authorizationAttribute, ok := attributes["authorization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authorization is missing from object`)

		return nil, diags
	}

	authorizationVal, ok := authorizationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authorization expected to be basetypes.ObjectValue, was: %T`, authorizationAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Authorization: authorizationVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	authorizationAttribute, ok := attributes["authorization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authorization is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	authorizationVal, ok := authorizationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authorization expected to be basetypes.ObjectValue, was: %T`, authorizationAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Authorization: authorizationVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Authorization basetypes.ObjectValue `tfsdk:"authorization"`
	state         attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["authorization"] = basetypes.ObjectType{
		AttrTypes: AuthorizationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Authorization.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authorization"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var authorizationVal basetypes.ObjectValue

	if v.Authorization.IsNull() {
		authorizationVal = types.ObjectNull(
			AuthorizationValue{}.AttributeTypes(ctx),
		)
	}

	if v.Authorization.IsUnknown() {
		authorizationVal = types.ObjectUnknown(
			AuthorizationValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Authorization.IsNull() && !v.Authorization.IsUnknown() {
		authorizationVal = types.ObjectValueMust(
			AuthorizationValue{}.AttributeTypes(ctx),
			v.Authorization.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"authorization": basetypes.ObjectType{
			AttrTypes: AuthorizationValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"authorization": authorizationVal,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Authorization.Equal(other.Authorization) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"authorization": basetypes.ObjectType{
			AttrTypes: AuthorizationValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AuthorizationType{}

type AuthorizationType struct {
	basetypes.ObjectType
}

func (t AuthorizationType) Equal(o attr.Type) bool {
	other, ok := o.(AuthorizationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthorizationType) String() string {
	return "AuthorizationType"
}

func (t AuthorizationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aivenAttribute, ok := attributes["aiven"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aiven is missing from object`)

		return nil, diags
	}

	aivenVal, ok := aivenAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aiven expected to be basetypes.ObjectValue, was: %T`, aivenAttribute))
	}

	kafkaAttribute, ok := attributes["kafka"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kafka is missing from object`)

		return nil, diags
	}

	kafkaVal, ok := kafkaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kafka expected to be basetypes.ObjectValue, was: %T`, kafkaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthorizationValue{
		Aiven: aivenVal,
		Kafka: kafkaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewAuthorizationValueNull() AuthorizationValue {
	return AuthorizationValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthorizationValueUnknown() AuthorizationValue {
	return AuthorizationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthorizationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthorizationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthorizationValue Attribute Value",
				"While creating a AuthorizationValue value, a missing attribute value was detected. "+
					"A AuthorizationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthorizationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthorizationValue Attribute Type",
				"While creating a AuthorizationValue value, an invalid attribute value was detected. "+
					"A AuthorizationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthorizationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthorizationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthorizationValue Attribute Value",
				"While creating a AuthorizationValue value, an extra attribute value was detected. "+
					"A AuthorizationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthorizationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthorizationValueUnknown(), diags
	}

	aivenAttribute, ok := attributes["aiven"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aiven is missing from object`)

		return NewAuthorizationValueUnknown(), diags
	}

	aivenVal, ok := aivenAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aiven expected to be basetypes.ObjectValue, was: %T`, aivenAttribute))
	}

	kafkaAttribute, ok := attributes["kafka"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kafka is missing from object`)

		return NewAuthorizationValueUnknown(), diags
	}

	kafkaVal, ok := kafkaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kafka expected to be basetypes.ObjectValue, was: %T`, kafkaAttribute))
	}

	if diags.HasError() {
		return NewAuthorizationValueUnknown(), diags
	}

	return AuthorizationValue{
		Aiven: aivenVal,
		Kafka: kafkaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewAuthorizationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthorizationValue {
	object, diags := NewAuthorizationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthorizationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthorizationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthorizationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthorizationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthorizationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthorizationValueMust(AuthorizationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthorizationType) ValueType(ctx context.Context) attr.Value {
	return AuthorizationValue{}
}

var _ basetypes.ObjectValuable = AuthorizationValue{}

type AuthorizationValue struct {
	Aiven basetypes.ObjectValue `tfsdk:"aiven"`
	Kafka basetypes.ObjectValue `tfsdk:"kafka"`
	state attr.ValueState
}

func (v AuthorizationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["aiven"] = basetypes.ObjectType{
		AttrTypes: AivenValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["kafka"] = basetypes.ObjectType{
		AttrTypes: KafkaValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Aiven.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aiven"] = val

		val, err = v.Kafka.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kafka"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthorizationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthorizationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthorizationValue) String() string {
	return "AuthorizationValue"
}

func (v AuthorizationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var aivenVal basetypes.ObjectValue

	if v.Aiven.IsNull() {
		aivenVal = types.ObjectNull(
			AivenValue{}.AttributeTypes(ctx),
		)
	}

	if v.Aiven.IsUnknown() {
		aivenVal = types.ObjectUnknown(
			AivenValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Aiven.IsNull() && !v.Aiven.IsUnknown() {
		aivenVal = types.ObjectValueMust(
			AivenValue{}.AttributeTypes(ctx),
			v.Aiven.Attributes(),
		)
	}

	var kafkaVal basetypes.ObjectValue

	if v.Kafka.IsNull() {
		kafkaVal = types.ObjectNull(
			KafkaValue{}.AttributeTypes(ctx),
		)
	}

	if v.Kafka.IsUnknown() {
		kafkaVal = types.ObjectUnknown(
			KafkaValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Kafka.IsNull() && !v.Kafka.IsUnknown() {
		kafkaVal = types.ObjectValueMust(
			KafkaValue{}.AttributeTypes(ctx),
			v.Kafka.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"aiven": basetypes.ObjectType{
			AttrTypes: AivenValue{}.AttributeTypes(ctx),
		},
		"kafka": basetypes.ObjectType{
			AttrTypes: KafkaValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"aiven": aivenVal,
			"kafka": kafkaVal,
		})

	return objVal, diags
}

func (v AuthorizationValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthorizationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Aiven.Equal(other.Aiven) {
		return false
	}

	if !v.Kafka.Equal(other.Kafka) {
		return false
	}

	return true
}

func (v AuthorizationValue) Type(ctx context.Context) attr.Type {
	return AuthorizationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthorizationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"aiven": basetypes.ObjectType{
			AttrTypes: AivenValue{}.AttributeTypes(ctx),
		},
		"kafka": basetypes.ObjectType{
			AttrTypes: KafkaValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AivenType{}

type AivenType struct {
	basetypes.ObjectType
}

func (t AivenType) Equal(o attr.Type) bool {
	other, ok := o.(AivenType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AivenType) String() string {
	return "AivenType"
}

func (t AivenType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aclsAttribute, ok := attributes["acls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acls is missing from object`)

		return nil, diags
	}

	aclsVal, ok := aclsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acls expected to be basetypes.SetValue, was: %T`, aclsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AivenValue{
		Acls:  aclsVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewAivenValueNull() AivenValue {
	return AivenValue{
		state: attr.ValueStateNull,
	}
}

func NewAivenValueUnknown() AivenValue {
	return AivenValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAivenValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AivenValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AivenValue Attribute Value",
				"While creating a AivenValue value, a missing attribute value was detected. "+
					"A AivenValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AivenValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AivenValue Attribute Type",
				"While creating a AivenValue value, an invalid attribute value was detected. "+
					"A AivenValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AivenValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AivenValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AivenValue Attribute Value",
				"While creating a AivenValue value, an extra attribute value was detected. "+
					"A AivenValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AivenValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAivenValueUnknown(), diags
	}

	aclsAttribute, ok := attributes["acls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acls is missing from object`)

		return NewAivenValueUnknown(), diags
	}

	aclsVal, ok := aclsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acls expected to be basetypes.SetValue, was: %T`, aclsAttribute))
	}

	if diags.HasError() {
		return NewAivenValueUnknown(), diags
	}

	return AivenValue{
		Acls:  aclsVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewAivenValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AivenValue {
	object, diags := NewAivenValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAivenValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AivenType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAivenValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAivenValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAivenValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAivenValueMust(AivenValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AivenType) ValueType(ctx context.Context) attr.Value {
	return AivenValue{}
}

var _ basetypes.ObjectValuable = AivenValue{}

type AivenValue struct {
	Acls  basetypes.SetValue `tfsdk:"acls"`
	state attr.ValueState
}

func (v AivenValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["acls"] = basetypes.SetType{
		ElemType: AivenAclsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Acls.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acls"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AivenValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AivenValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AivenValue) String() string {
	return "AivenValue"
}

func (v AivenValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	acls := types.SetValueMust(
		AivenAclsType{
			basetypes.ObjectType{
				AttrTypes: AivenAclsValue{}.AttributeTypes(ctx),
			},
		},
		v.Acls.Elements(),
	)

	if v.Acls.IsNull() {
		acls = types.SetNull(
			AivenAclsType{
				basetypes.ObjectType{
					AttrTypes: AivenAclsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Acls.IsUnknown() {
		acls = types.SetUnknown(
			AivenAclsType{
				basetypes.ObjectType{
					AttrTypes: AivenAclsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"acls": basetypes.SetType{
			ElemType: AivenAclsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"acls": acls,
		})

	return objVal, diags
}

func (v AivenValue) Equal(o attr.Value) bool {
	other, ok := o.(AivenValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Acls.Equal(other.Acls) {
		return false
	}

	return true
}

func (v AivenValue) Type(ctx context.Context) attr.Type {
	return AivenType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AivenValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"acls": basetypes.SetType{
			ElemType: AivenAclsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AivenAclsType{}

type AivenAclsType struct {
	basetypes.ObjectType
}

func (t AivenAclsType) Equal(o attr.Type) bool {
	other, ok := o.(AivenAclsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AivenAclsType) String() string {
	return "AivenAclsType"
}

func (t AivenAclsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	permissionAttribute, ok := attributes["permission"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission is missing from object`)

		return nil, diags
	}

	permissionVal, ok := permissionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission expected to be basetypes.StringValue, was: %T`, permissionAttribute))
	}

	resourceTypeAttribute, ok := attributes["resource_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_type is missing from object`)

		return nil, diags
	}

	resourceTypeVal, ok := resourceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_type expected to be basetypes.StringValue, was: %T`, resourceTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AivenAclsValue{
		Name:         nameVal,
		Permission:   permissionVal,
		ResourceType: resourceTypeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewAivenAclsValueNull() AivenAclsValue {
	return AivenAclsValue{
		state: attr.ValueStateNull,
	}
}

func NewAivenAclsValueUnknown() AivenAclsValue {
	return AivenAclsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAivenAclsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AivenAclsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AivenAclsValue Attribute Value",
				"While creating a AivenAclsValue value, a missing attribute value was detected. "+
					"A AivenAclsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AivenAclsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AivenAclsValue Attribute Type",
				"While creating a AivenAclsValue value, an invalid attribute value was detected. "+
					"A AivenAclsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AivenAclsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AivenAclsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AivenAclsValue Attribute Value",
				"While creating a AivenAclsValue value, an extra attribute value was detected. "+
					"A AivenAclsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AivenAclsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAivenAclsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewAivenAclsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	permissionAttribute, ok := attributes["permission"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission is missing from object`)

		return NewAivenAclsValueUnknown(), diags
	}

	permissionVal, ok := permissionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission expected to be basetypes.StringValue, was: %T`, permissionAttribute))
	}

	resourceTypeAttribute, ok := attributes["resource_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_type is missing from object`)

		return NewAivenAclsValueUnknown(), diags
	}

	resourceTypeVal, ok := resourceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_type expected to be basetypes.StringValue, was: %T`, resourceTypeAttribute))
	}

	if diags.HasError() {
		return NewAivenAclsValueUnknown(), diags
	}

	return AivenAclsValue{
		Name:         nameVal,
		Permission:   permissionVal,
		ResourceType: resourceTypeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewAivenAclsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AivenAclsValue {
	object, diags := NewAivenAclsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAivenAclsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AivenAclsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAivenAclsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAivenAclsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAivenAclsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAivenAclsValueMust(AivenAclsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AivenAclsType) ValueType(ctx context.Context) attr.Value {
	return AivenAclsValue{}
}

var _ basetypes.ObjectValuable = AivenAclsValue{}

type AivenAclsValue struct {
	Name         basetypes.StringValue `tfsdk:"name"`
	Permission   basetypes.StringValue `tfsdk:"permission"`
	ResourceType basetypes.StringValue `tfsdk:"resource_type"`
	state        attr.ValueState
}

func (v AivenAclsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["permission"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Permission.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["permission"] = val

		val, err = v.ResourceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AivenAclsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AivenAclsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AivenAclsValue) String() string {
	return "AivenAclsValue"
}

func (v AivenAclsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":          basetypes.StringType{},
		"permission":    basetypes.StringType{},
		"resource_type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":          v.Name,
			"permission":    v.Permission,
			"resource_type": v.ResourceType,
		})

	return objVal, diags
}

func (v AivenAclsValue) Equal(o attr.Value) bool {
	other, ok := o.(AivenAclsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Permission.Equal(other.Permission) {
		return false
	}

	if !v.ResourceType.Equal(other.ResourceType) {
		return false
	}

	return true
}

func (v AivenAclsValue) Type(ctx context.Context) attr.Type {
	return AivenAclsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AivenAclsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":          basetypes.StringType{},
		"permission":    basetypes.StringType{},
		"resource_type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = KafkaType{}

type KafkaType struct {
	basetypes.ObjectType
}

func (t KafkaType) Equal(o attr.Type) bool {
	other, ok := o.(KafkaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t KafkaType) String() string {
	return "KafkaType"
}

func (t KafkaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aclsAttribute, ok := attributes["acls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acls is missing from object`)

		return nil, diags
	}

	aclsVal, ok := aclsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acls expected to be basetypes.SetValue, was: %T`, aclsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return KafkaValue{
		Acls:  aclsVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewKafkaValueNull() KafkaValue {
	return KafkaValue{
		state: attr.ValueStateNull,
	}
}

func NewKafkaValueUnknown() KafkaValue {
	return KafkaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewKafkaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (KafkaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing KafkaValue Attribute Value",
				"While creating a KafkaValue value, a missing attribute value was detected. "+
					"A KafkaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KafkaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid KafkaValue Attribute Type",
				"While creating a KafkaValue value, an invalid attribute value was detected. "+
					"A KafkaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KafkaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("KafkaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra KafkaValue Attribute Value",
				"While creating a KafkaValue value, an extra attribute value was detected. "+
					"A KafkaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra KafkaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewKafkaValueUnknown(), diags
	}

	aclsAttribute, ok := attributes["acls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acls is missing from object`)

		return NewKafkaValueUnknown(), diags
	}

	aclsVal, ok := aclsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acls expected to be basetypes.SetValue, was: %T`, aclsAttribute))
	}

	if diags.HasError() {
		return NewKafkaValueUnknown(), diags
	}

	return KafkaValue{
		Acls:  aclsVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewKafkaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) KafkaValue {
	object, diags := NewKafkaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewKafkaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t KafkaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewKafkaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewKafkaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewKafkaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewKafkaValueMust(KafkaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t KafkaType) ValueType(ctx context.Context) attr.Value {
	return KafkaValue{}
}

var _ basetypes.ObjectValuable = KafkaValue{}

type KafkaValue struct {
	Acls  basetypes.SetValue `tfsdk:"acls"`
	state attr.ValueState
}

func (v KafkaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["acls"] = basetypes.SetType{
		ElemType: KafkaAclsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Acls.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acls"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v KafkaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v KafkaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v KafkaValue) String() string {
	return "KafkaValue"
}

func (v KafkaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	acls := types.SetValueMust(
		KafkaAclsType{
			basetypes.ObjectType{
				AttrTypes: KafkaAclsValue{}.AttributeTypes(ctx),
			},
		},
		v.Acls.Elements(),
	)

	if v.Acls.IsNull() {
		acls = types.SetNull(
			KafkaAclsType{
				basetypes.ObjectType{
					AttrTypes: KafkaAclsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Acls.IsUnknown() {
		acls = types.SetUnknown(
			KafkaAclsType{
				basetypes.ObjectType{
					AttrTypes: KafkaAclsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"acls": basetypes.SetType{
			ElemType: KafkaAclsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"acls": acls,
		})

	return objVal, diags
}

func (v KafkaValue) Equal(o attr.Value) bool {
	other, ok := o.(KafkaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Acls.Equal(other.Acls) {
		return false
	}

	return true
}

func (v KafkaValue) Type(ctx context.Context) attr.Type {
	return KafkaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v KafkaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"acls": basetypes.SetType{
			ElemType: KafkaAclsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = KafkaAclsType{}

type KafkaAclsType struct {
	basetypes.ObjectType
}

func (t KafkaAclsType) Equal(o attr.Type) bool {
	other, ok := o.(KafkaAclsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t KafkaAclsType) String() string {
	return "KafkaAclsType"
}

func (t KafkaAclsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	connectClusterAttribute, ok := attributes["connect_cluster"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connect_cluster is missing from object`)

		return nil, diags
	}

	connectClusterVal, ok := connectClusterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connect_cluster expected to be basetypes.StringValue, was: %T`, connectClusterAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	operationsAttribute, ok := attributes["operations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operations is missing from object`)

		return nil, diags
	}

	operationsVal, ok := operationsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operations expected to be basetypes.SetValue, was: %T`, operationsAttribute))
	}

	patternTypeAttribute, ok := attributes["pattern_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pattern_type is missing from object`)

		return nil, diags
	}

	patternTypeVal, ok := patternTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pattern_type expected to be basetypes.StringValue, was: %T`, patternTypeAttribute))
	}

	permissionAttribute, ok := attributes["permission"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission is missing from object`)

		return nil, diags
	}

	permissionVal, ok := permissionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission expected to be basetypes.StringValue, was: %T`, permissionAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return KafkaAclsValue{
		ConnectCluster: connectClusterVal,
		Host:           hostVal,
		Name:           nameVal,
		Operations:     operationsVal,
		PatternType:    patternTypeVal,
		Permission:     permissionVal,
		KafkaAclsType:  typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewKafkaAclsValueNull() KafkaAclsValue {
	return KafkaAclsValue{
		state: attr.ValueStateNull,
	}
}

func NewKafkaAclsValueUnknown() KafkaAclsValue {
	return KafkaAclsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewKafkaAclsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (KafkaAclsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing KafkaAclsValue Attribute Value",
				"While creating a KafkaAclsValue value, a missing attribute value was detected. "+
					"A KafkaAclsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KafkaAclsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid KafkaAclsValue Attribute Type",
				"While creating a KafkaAclsValue value, an invalid attribute value was detected. "+
					"A KafkaAclsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KafkaAclsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("KafkaAclsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra KafkaAclsValue Attribute Value",
				"While creating a KafkaAclsValue value, an extra attribute value was detected. "+
					"A KafkaAclsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra KafkaAclsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewKafkaAclsValueUnknown(), diags
	}

	connectClusterAttribute, ok := attributes["connect_cluster"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connect_cluster is missing from object`)

		return NewKafkaAclsValueUnknown(), diags
	}

	connectClusterVal, ok := connectClusterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connect_cluster expected to be basetypes.StringValue, was: %T`, connectClusterAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewKafkaAclsValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewKafkaAclsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	operationsAttribute, ok := attributes["operations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operations is missing from object`)

		return NewKafkaAclsValueUnknown(), diags
	}

	operationsVal, ok := operationsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operations expected to be basetypes.SetValue, was: %T`, operationsAttribute))
	}

	patternTypeAttribute, ok := attributes["pattern_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pattern_type is missing from object`)

		return NewKafkaAclsValueUnknown(), diags
	}

	patternTypeVal, ok := patternTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pattern_type expected to be basetypes.StringValue, was: %T`, patternTypeAttribute))
	}

	permissionAttribute, ok := attributes["permission"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission is missing from object`)

		return NewKafkaAclsValueUnknown(), diags
	}

	permissionVal, ok := permissionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission expected to be basetypes.StringValue, was: %T`, permissionAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewKafkaAclsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewKafkaAclsValueUnknown(), diags
	}

	return KafkaAclsValue{
		ConnectCluster: connectClusterVal,
		Host:           hostVal,
		Name:           nameVal,
		Operations:     operationsVal,
		PatternType:    patternTypeVal,
		Permission:     permissionVal,
		KafkaAclsType:  typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewKafkaAclsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) KafkaAclsValue {
	object, diags := NewKafkaAclsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewKafkaAclsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t KafkaAclsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewKafkaAclsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewKafkaAclsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewKafkaAclsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewKafkaAclsValueMust(KafkaAclsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t KafkaAclsType) ValueType(ctx context.Context) attr.Value {
	return KafkaAclsValue{}
}

var _ basetypes.ObjectValuable = KafkaAclsValue{}

type KafkaAclsValue struct {
	ConnectCluster basetypes.StringValue `tfsdk:"connect_cluster"`
	Host           basetypes.StringValue `tfsdk:"host"`
	Name           basetypes.StringValue `tfsdk:"name"`
	Operations     basetypes.SetValue    `tfsdk:"operations"`
	PatternType    basetypes.StringValue `tfsdk:"pattern_type"`
	Permission     basetypes.StringValue `tfsdk:"permission"`
	KafkaAclsType  basetypes.StringValue `tfsdk:"type"`
	state          attr.ValueState
}

func (v KafkaAclsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["connect_cluster"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operations"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["pattern_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["permission"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.ConnectCluster.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["connect_cluster"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Operations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operations"] = val

		val, err = v.PatternType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pattern_type"] = val

		val, err = v.Permission.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["permission"] = val

		val, err = v.KafkaAclsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v KafkaAclsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v KafkaAclsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v KafkaAclsValue) String() string {
	return "KafkaAclsValue"
}

func (v KafkaAclsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var operationsVal basetypes.SetValue
	switch {
	case v.Operations.IsUnknown():
		operationsVal = types.SetUnknown(types.StringType)
	case v.Operations.IsNull():
		operationsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		operationsVal, d = types.SetValue(types.StringType, v.Operations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"connect_cluster": basetypes.StringType{},
			"host":            basetypes.StringType{},
			"name":            basetypes.StringType{},
			"operations": basetypes.SetType{
				ElemType: types.StringType,
			},
			"pattern_type": basetypes.StringType{},
			"permission":   basetypes.StringType{},
			"type":         basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"connect_cluster": basetypes.StringType{},
		"host":            basetypes.StringType{},
		"name":            basetypes.StringType{},
		"operations": basetypes.SetType{
			ElemType: types.StringType,
		},
		"pattern_type": basetypes.StringType{},
		"permission":   basetypes.StringType{},
		"type":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"connect_cluster": v.ConnectCluster,
			"host":            v.Host,
			"name":            v.Name,
			"operations":      operationsVal,
			"pattern_type":    v.PatternType,
			"permission":      v.Permission,
			"type":            v.KafkaAclsType,
		})

	return objVal, diags
}

func (v KafkaAclsValue) Equal(o attr.Value) bool {
	other, ok := o.(KafkaAclsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConnectCluster.Equal(other.ConnectCluster) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Operations.Equal(other.Operations) {
		return false
	}

	if !v.PatternType.Equal(other.PatternType) {
		return false
	}

	if !v.Permission.Equal(other.Permission) {
		return false
	}

	if !v.KafkaAclsType.Equal(other.KafkaAclsType) {
		return false
	}

	return true
}

func (v KafkaAclsValue) Type(ctx context.Context) attr.Type {
	return KafkaAclsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v KafkaAclsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"connect_cluster": basetypes.StringType{},
		"host":            basetypes.StringType{},
		"name":            basetypes.StringType{},
		"operations": basetypes.SetType{
			ElemType: types.StringType,
		},
		"pattern_type": basetypes.StringType{},
		"permission":   basetypes.StringType{},
		"type":         basetypes.StringType{},
	}
}
