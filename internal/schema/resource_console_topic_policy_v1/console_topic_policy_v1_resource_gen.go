// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_console_topic_policy_v1

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func ConsoleTopicPolicyV1ResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "Topic Policy name, must be unique, acts as an ID for import",
				MarkdownDescription: "Topic Policy name, must be unique, acts as an ID for import",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^[0-9a-z\\_\\-]+$"), ""),
				},
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"policies": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"allowed_keys": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"keys": schema.SetAttribute{
											ElementType: types.StringType,
											Required:    true,
										},
										"optional": schema.BoolAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "If set to true, the policy is optional",
											MarkdownDescription: "If set to true, the policy is optional",
										},
									},
									CustomType: AllowedKeysType{
										ObjectType: types.ObjectType{
											AttrTypes: AllowedKeysValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Validates the keys are within an allowed key list",
									MarkdownDescription: "Validates the keys are within an allowed key list",
								},
								"match": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"optional": schema.BoolAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "If set to true, the policy is optional",
											MarkdownDescription: "If set to true, the policy is optional",
										},
										"pattern": schema.StringAttribute{
											Required: true,
										},
									},
									CustomType: MatchType{
										ObjectType: types.ObjectType{
											AttrTypes: MatchValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Validates using Regular Expression",
									MarkdownDescription: "Validates using Regular Expression",
								},
								"none_of": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"optional": schema.BoolAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "If set to true, the policy is optional",
											MarkdownDescription: "If set to true, the policy is optional",
										},
										"values": schema.SetAttribute{
											ElementType: types.StringType,
											Required:    true,
										},
									},
									CustomType: NoneOfType{
										ObjectType: types.ObjectType{
											AttrTypes: NoneOfValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Validates against a list of predefined options",
									MarkdownDescription: "Validates against a list of predefined options",
								},
								"one_of": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"optional": schema.BoolAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "If set to true, the policy is optional",
											MarkdownDescription: "If set to true, the policy is optional",
										},
										"values": schema.SetAttribute{
											ElementType: types.StringType,
											Required:    true,
										},
									},
									CustomType: OneOfType{
										ObjectType: types.ObjectType{
											AttrTypes: OneOfValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Validates against a list of predefined options",
									MarkdownDescription: "Validates against a list of predefined options",
								},
								"range": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"max": schema.Int64Attribute{
											Required: true,
										},
										"min": schema.Int64Attribute{
											Required: true,
										},
										"optional": schema.BoolAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "If set to true, the policy is optional",
											MarkdownDescription: "If set to true, the policy is optional",
										},
									},
									CustomType: RangeType{
										ObjectType: types.ObjectType{
											AttrTypes: RangeValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Validates a range of numbers",
									MarkdownDescription: "Validates a range of numbers",
								},
							},
							CustomType: PoliciesType{
								ObjectType: types.ObjectType{
									AttrTypes: PoliciesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Required:            true,
						Description:         "Map of policies",
						MarkdownDescription: "Map of policies",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "Topic Policy specification",
				MarkdownDescription: "Topic Policy specification",
			},
		},
	}
}

type ConsoleTopicPolicyV1Model struct {
	Name types.String `tfsdk:"name"`
	Spec SpecValue    `tfsdk:"spec"`
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	policiesAttribute, ok := attributes["policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policies is missing from object`)

		return nil, diags
	}

	policiesVal, ok := policiesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policies expected to be basetypes.MapValue, was: %T`, policiesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Policies: policiesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	policiesAttribute, ok := attributes["policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policies is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	policiesVal, ok := policiesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policies expected to be basetypes.MapValue, was: %T`, policiesAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Policies: policiesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Policies basetypes.MapValue `tfsdk:"policies"`
	state    attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["policies"] = basetypes.MapType{
		ElemType: PoliciesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Policies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policies"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	policies := types.MapValueMust(
		PoliciesType{
			basetypes.ObjectType{
				AttrTypes: PoliciesValue{}.AttributeTypes(ctx),
			},
		},
		v.Policies.Elements(),
	)

	if v.Policies.IsNull() {
		policies = types.MapNull(
			PoliciesType{
				basetypes.ObjectType{
					AttrTypes: PoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Policies.IsUnknown() {
		policies = types.MapUnknown(
			PoliciesType{
				basetypes.ObjectType{
					AttrTypes: PoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"policies": basetypes.MapType{
			ElemType: PoliciesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"policies": policies,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Policies.Equal(other.Policies) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"policies": basetypes.MapType{
			ElemType: PoliciesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PoliciesType{}

type PoliciesType struct {
	basetypes.ObjectType
}

func (t PoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(PoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PoliciesType) String() string {
	return "PoliciesType"
}

func (t PoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowedKeysAttribute, ok := attributes["allowed_keys"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_keys is missing from object`)

		return nil, diags
	}

	allowedKeysVal, ok := allowedKeysAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_keys expected to be basetypes.ObjectValue, was: %T`, allowedKeysAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return nil, diags
	}

	matchVal, ok := matchAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.ObjectValue, was: %T`, matchAttribute))
	}

	noneOfAttribute, ok := attributes["none_of"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`none_of is missing from object`)

		return nil, diags
	}

	noneOfVal, ok := noneOfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`none_of expected to be basetypes.ObjectValue, was: %T`, noneOfAttribute))
	}

	oneOfAttribute, ok := attributes["one_of"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_of is missing from object`)

		return nil, diags
	}

	oneOfVal, ok := oneOfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_of expected to be basetypes.ObjectValue, was: %T`, oneOfAttribute))
	}

	rangeAttribute, ok := attributes["range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`range is missing from object`)

		return nil, diags
	}

	rangeVal, ok := rangeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`range expected to be basetypes.ObjectValue, was: %T`, rangeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PoliciesValue{
		AllowedKeys: allowedKeysVal,
		Match:       matchVal,
		NoneOf:      noneOfVal,
		OneOf:       oneOfVal,
		Range:       rangeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPoliciesValueNull() PoliciesValue {
	return PoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewPoliciesValueUnknown() PoliciesValue {
	return PoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PoliciesValue Attribute Value",
				"While creating a PoliciesValue value, a missing attribute value was detected. "+
					"A PoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PoliciesValue Attribute Type",
				"While creating a PoliciesValue value, an invalid attribute value was detected. "+
					"A PoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PoliciesValue Attribute Value",
				"While creating a PoliciesValue value, an extra attribute value was detected. "+
					"A PoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPoliciesValueUnknown(), diags
	}

	allowedKeysAttribute, ok := attributes["allowed_keys"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_keys is missing from object`)

		return NewPoliciesValueUnknown(), diags
	}

	allowedKeysVal, ok := allowedKeysAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_keys expected to be basetypes.ObjectValue, was: %T`, allowedKeysAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return NewPoliciesValueUnknown(), diags
	}

	matchVal, ok := matchAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.ObjectValue, was: %T`, matchAttribute))
	}

	noneOfAttribute, ok := attributes["none_of"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`none_of is missing from object`)

		return NewPoliciesValueUnknown(), diags
	}

	noneOfVal, ok := noneOfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`none_of expected to be basetypes.ObjectValue, was: %T`, noneOfAttribute))
	}

	oneOfAttribute, ok := attributes["one_of"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_of is missing from object`)

		return NewPoliciesValueUnknown(), diags
	}

	oneOfVal, ok := oneOfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_of expected to be basetypes.ObjectValue, was: %T`, oneOfAttribute))
	}

	rangeAttribute, ok := attributes["range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`range is missing from object`)

		return NewPoliciesValueUnknown(), diags
	}

	rangeVal, ok := rangeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`range expected to be basetypes.ObjectValue, was: %T`, rangeAttribute))
	}

	if diags.HasError() {
		return NewPoliciesValueUnknown(), diags
	}

	return PoliciesValue{
		AllowedKeys: allowedKeysVal,
		Match:       matchVal,
		NoneOf:      noneOfVal,
		OneOf:       oneOfVal,
		Range:       rangeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PoliciesValue {
	object, diags := NewPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPoliciesValueMust(PoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PoliciesType) ValueType(ctx context.Context) attr.Value {
	return PoliciesValue{}
}

var _ basetypes.ObjectValuable = PoliciesValue{}

type PoliciesValue struct {
	AllowedKeys basetypes.ObjectValue `tfsdk:"allowed_keys"`
	Match       basetypes.ObjectValue `tfsdk:"match"`
	NoneOf      basetypes.ObjectValue `tfsdk:"none_of"`
	OneOf       basetypes.ObjectValue `tfsdk:"one_of"`
	Range       basetypes.ObjectValue `tfsdk:"range"`
	state       attr.ValueState
}

func (v PoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["allowed_keys"] = basetypes.ObjectType{
		AttrTypes: AllowedKeysValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["match"] = basetypes.ObjectType{
		AttrTypes: MatchValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["none_of"] = basetypes.ObjectType{
		AttrTypes: NoneOfValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["one_of"] = basetypes.ObjectType{
		AttrTypes: OneOfValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["range"] = basetypes.ObjectType{
		AttrTypes: RangeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AllowedKeys.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allowed_keys"] = val

		val, err = v.Match.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match"] = val

		val, err = v.NoneOf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["none_of"] = val

		val, err = v.OneOf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["one_of"] = val

		val, err = v.Range.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["range"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PoliciesValue) String() string {
	return "PoliciesValue"
}

func (v PoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var allowedKeysVal basetypes.ObjectValue

	if v.AllowedKeys.IsNull() {
		allowedKeysVal = types.ObjectNull(
			AllowedKeysValue{}.AttributeTypes(ctx),
		)
	}

	if v.AllowedKeys.IsUnknown() {
		allowedKeysVal = types.ObjectUnknown(
			AllowedKeysValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AllowedKeys.IsNull() && !v.AllowedKeys.IsUnknown() {
		allowedKeysVal = types.ObjectValueMust(
			AllowedKeysValue{}.AttributeTypes(ctx),
			v.AllowedKeys.Attributes(),
		)
	}

	var matchVal basetypes.ObjectValue

	if v.Match.IsNull() {
		matchVal = types.ObjectNull(
			MatchValue{}.AttributeTypes(ctx),
		)
	}

	if v.Match.IsUnknown() {
		matchVal = types.ObjectUnknown(
			MatchValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Match.IsNull() && !v.Match.IsUnknown() {
		matchVal = types.ObjectValueMust(
			MatchValue{}.AttributeTypes(ctx),
			v.Match.Attributes(),
		)
	}

	var noneOfVal basetypes.ObjectValue

	if v.NoneOf.IsNull() {
		noneOfVal = types.ObjectNull(
			NoneOfValue{}.AttributeTypes(ctx),
		)
	}

	if v.NoneOf.IsUnknown() {
		noneOfVal = types.ObjectUnknown(
			NoneOfValue{}.AttributeTypes(ctx),
		)
	}

	if !v.NoneOf.IsNull() && !v.NoneOf.IsUnknown() {
		noneOfVal = types.ObjectValueMust(
			NoneOfValue{}.AttributeTypes(ctx),
			v.NoneOf.Attributes(),
		)
	}

	var oneOfVal basetypes.ObjectValue

	if v.OneOf.IsNull() {
		oneOfVal = types.ObjectNull(
			OneOfValue{}.AttributeTypes(ctx),
		)
	}

	if v.OneOf.IsUnknown() {
		oneOfVal = types.ObjectUnknown(
			OneOfValue{}.AttributeTypes(ctx),
		)
	}

	if !v.OneOf.IsNull() && !v.OneOf.IsUnknown() {
		oneOfVal = types.ObjectValueMust(
			OneOfValue{}.AttributeTypes(ctx),
			v.OneOf.Attributes(),
		)
	}

	var rangeVal basetypes.ObjectValue

	if v.Range.IsNull() {
		rangeVal = types.ObjectNull(
			RangeValue{}.AttributeTypes(ctx),
		)
	}

	if v.Range.IsUnknown() {
		rangeVal = types.ObjectUnknown(
			RangeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Range.IsNull() && !v.Range.IsUnknown() {
		rangeVal = types.ObjectValueMust(
			RangeValue{}.AttributeTypes(ctx),
			v.Range.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"allowed_keys": basetypes.ObjectType{
			AttrTypes: AllowedKeysValue{}.AttributeTypes(ctx),
		},
		"match": basetypes.ObjectType{
			AttrTypes: MatchValue{}.AttributeTypes(ctx),
		},
		"none_of": basetypes.ObjectType{
			AttrTypes: NoneOfValue{}.AttributeTypes(ctx),
		},
		"one_of": basetypes.ObjectType{
			AttrTypes: OneOfValue{}.AttributeTypes(ctx),
		},
		"range": basetypes.ObjectType{
			AttrTypes: RangeValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allowed_keys": allowedKeysVal,
			"match":        matchVal,
			"none_of":      noneOfVal,
			"one_of":       oneOfVal,
			"range":        rangeVal,
		})

	return objVal, diags
}

func (v PoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(PoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowedKeys.Equal(other.AllowedKeys) {
		return false
	}

	if !v.Match.Equal(other.Match) {
		return false
	}

	if !v.NoneOf.Equal(other.NoneOf) {
		return false
	}

	if !v.OneOf.Equal(other.OneOf) {
		return false
	}

	if !v.Range.Equal(other.Range) {
		return false
	}

	return true
}

func (v PoliciesValue) Type(ctx context.Context) attr.Type {
	return PoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allowed_keys": basetypes.ObjectType{
			AttrTypes: AllowedKeysValue{}.AttributeTypes(ctx),
		},
		"match": basetypes.ObjectType{
			AttrTypes: MatchValue{}.AttributeTypes(ctx),
		},
		"none_of": basetypes.ObjectType{
			AttrTypes: NoneOfValue{}.AttributeTypes(ctx),
		},
		"one_of": basetypes.ObjectType{
			AttrTypes: OneOfValue{}.AttributeTypes(ctx),
		},
		"range": basetypes.ObjectType{
			AttrTypes: RangeValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AllowedKeysType{}

type AllowedKeysType struct {
	basetypes.ObjectType
}

func (t AllowedKeysType) Equal(o attr.Type) bool {
	other, ok := o.(AllowedKeysType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AllowedKeysType) String() string {
	return "AllowedKeysType"
}

func (t AllowedKeysType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	keysAttribute, ok := attributes["keys"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keys is missing from object`)

		return nil, diags
	}

	keysVal, ok := keysAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keys expected to be basetypes.SetValue, was: %T`, keysAttribute))
	}

	optionalAttribute, ok := attributes["optional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`optional is missing from object`)

		return nil, diags
	}

	optionalVal, ok := optionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`optional expected to be basetypes.BoolValue, was: %T`, optionalAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AllowedKeysValue{
		Keys:     keysVal,
		Optional: optionalVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAllowedKeysValueNull() AllowedKeysValue {
	return AllowedKeysValue{
		state: attr.ValueStateNull,
	}
}

func NewAllowedKeysValueUnknown() AllowedKeysValue {
	return AllowedKeysValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAllowedKeysValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AllowedKeysValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AllowedKeysValue Attribute Value",
				"While creating a AllowedKeysValue value, a missing attribute value was detected. "+
					"A AllowedKeysValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AllowedKeysValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AllowedKeysValue Attribute Type",
				"While creating a AllowedKeysValue value, an invalid attribute value was detected. "+
					"A AllowedKeysValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AllowedKeysValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AllowedKeysValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AllowedKeysValue Attribute Value",
				"While creating a AllowedKeysValue value, an extra attribute value was detected. "+
					"A AllowedKeysValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AllowedKeysValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAllowedKeysValueUnknown(), diags
	}

	keysAttribute, ok := attributes["keys"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keys is missing from object`)

		return NewAllowedKeysValueUnknown(), diags
	}

	keysVal, ok := keysAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keys expected to be basetypes.SetValue, was: %T`, keysAttribute))
	}

	optionalAttribute, ok := attributes["optional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`optional is missing from object`)

		return NewAllowedKeysValueUnknown(), diags
	}

	optionalVal, ok := optionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`optional expected to be basetypes.BoolValue, was: %T`, optionalAttribute))
	}

	if diags.HasError() {
		return NewAllowedKeysValueUnknown(), diags
	}

	return AllowedKeysValue{
		Keys:     keysVal,
		Optional: optionalVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAllowedKeysValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AllowedKeysValue {
	object, diags := NewAllowedKeysValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAllowedKeysValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AllowedKeysType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAllowedKeysValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAllowedKeysValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAllowedKeysValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAllowedKeysValueMust(AllowedKeysValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AllowedKeysType) ValueType(ctx context.Context) attr.Value {
	return AllowedKeysValue{}
}

var _ basetypes.ObjectValuable = AllowedKeysValue{}

type AllowedKeysValue struct {
	Keys     basetypes.SetValue  `tfsdk:"keys"`
	Optional basetypes.BoolValue `tfsdk:"optional"`
	state    attr.ValueState
}

func (v AllowedKeysValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["keys"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["optional"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Keys.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keys"] = val

		val, err = v.Optional.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["optional"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AllowedKeysValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AllowedKeysValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AllowedKeysValue) String() string {
	return "AllowedKeysValue"
}

func (v AllowedKeysValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var keysVal basetypes.SetValue
	switch {
	case v.Keys.IsUnknown():
		keysVal = types.SetUnknown(types.StringType)
	case v.Keys.IsNull():
		keysVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		keysVal, d = types.SetValue(types.StringType, v.Keys.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"keys": basetypes.SetType{
				ElemType: types.StringType,
			},
			"optional": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"keys": basetypes.SetType{
			ElemType: types.StringType,
		},
		"optional": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"keys":     keysVal,
			"optional": v.Optional,
		})

	return objVal, diags
}

func (v AllowedKeysValue) Equal(o attr.Value) bool {
	other, ok := o.(AllowedKeysValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Keys.Equal(other.Keys) {
		return false
	}

	if !v.Optional.Equal(other.Optional) {
		return false
	}

	return true
}

func (v AllowedKeysValue) Type(ctx context.Context) attr.Type {
	return AllowedKeysType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AllowedKeysValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"keys": basetypes.SetType{
			ElemType: types.StringType,
		},
		"optional": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MatchType{}

type MatchType struct {
	basetypes.ObjectType
}

func (t MatchType) Equal(o attr.Type) bool {
	other, ok := o.(MatchType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MatchType) String() string {
	return "MatchType"
}

func (t MatchType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	optionalAttribute, ok := attributes["optional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`optional is missing from object`)

		return nil, diags
	}

	optionalVal, ok := optionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`optional expected to be basetypes.BoolValue, was: %T`, optionalAttribute))
	}

	patternAttribute, ok := attributes["pattern"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pattern is missing from object`)

		return nil, diags
	}

	patternVal, ok := patternAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pattern expected to be basetypes.StringValue, was: %T`, patternAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MatchValue{
		Optional: optionalVal,
		Pattern:  patternVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewMatchValueNull() MatchValue {
	return MatchValue{
		state: attr.ValueStateNull,
	}
}

func NewMatchValueUnknown() MatchValue {
	return MatchValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMatchValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MatchValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MatchValue Attribute Value",
				"While creating a MatchValue value, a missing attribute value was detected. "+
					"A MatchValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MatchValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MatchValue Attribute Type",
				"While creating a MatchValue value, an invalid attribute value was detected. "+
					"A MatchValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MatchValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MatchValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MatchValue Attribute Value",
				"While creating a MatchValue value, an extra attribute value was detected. "+
					"A MatchValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MatchValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMatchValueUnknown(), diags
	}

	optionalAttribute, ok := attributes["optional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`optional is missing from object`)

		return NewMatchValueUnknown(), diags
	}

	optionalVal, ok := optionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`optional expected to be basetypes.BoolValue, was: %T`, optionalAttribute))
	}

	patternAttribute, ok := attributes["pattern"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pattern is missing from object`)

		return NewMatchValueUnknown(), diags
	}

	patternVal, ok := patternAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pattern expected to be basetypes.StringValue, was: %T`, patternAttribute))
	}

	if diags.HasError() {
		return NewMatchValueUnknown(), diags
	}

	return MatchValue{
		Optional: optionalVal,
		Pattern:  patternVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewMatchValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MatchValue {
	object, diags := NewMatchValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMatchValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MatchType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMatchValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMatchValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMatchValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMatchValueMust(MatchValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MatchType) ValueType(ctx context.Context) attr.Value {
	return MatchValue{}
}

var _ basetypes.ObjectValuable = MatchValue{}

type MatchValue struct {
	Optional basetypes.BoolValue   `tfsdk:"optional"`
	Pattern  basetypes.StringValue `tfsdk:"pattern"`
	state    attr.ValueState
}

func (v MatchValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["optional"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["pattern"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Optional.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["optional"] = val

		val, err = v.Pattern.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pattern"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MatchValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MatchValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MatchValue) String() string {
	return "MatchValue"
}

func (v MatchValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"optional": basetypes.BoolType{},
		"pattern":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"optional": v.Optional,
			"pattern":  v.Pattern,
		})

	return objVal, diags
}

func (v MatchValue) Equal(o attr.Value) bool {
	other, ok := o.(MatchValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Optional.Equal(other.Optional) {
		return false
	}

	if !v.Pattern.Equal(other.Pattern) {
		return false
	}

	return true
}

func (v MatchValue) Type(ctx context.Context) attr.Type {
	return MatchType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MatchValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"optional": basetypes.BoolType{},
		"pattern":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NoneOfType{}

type NoneOfType struct {
	basetypes.ObjectType
}

func (t NoneOfType) Equal(o attr.Type) bool {
	other, ok := o.(NoneOfType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NoneOfType) String() string {
	return "NoneOfType"
}

func (t NoneOfType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	optionalAttribute, ok := attributes["optional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`optional is missing from object`)

		return nil, diags
	}

	optionalVal, ok := optionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`optional expected to be basetypes.BoolValue, was: %T`, optionalAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return nil, diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.SetValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NoneOfValue{
		Optional: optionalVal,
		Values:   valuesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewNoneOfValueNull() NoneOfValue {
	return NoneOfValue{
		state: attr.ValueStateNull,
	}
}

func NewNoneOfValueUnknown() NoneOfValue {
	return NoneOfValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNoneOfValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NoneOfValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NoneOfValue Attribute Value",
				"While creating a NoneOfValue value, a missing attribute value was detected. "+
					"A NoneOfValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NoneOfValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NoneOfValue Attribute Type",
				"While creating a NoneOfValue value, an invalid attribute value was detected. "+
					"A NoneOfValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NoneOfValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NoneOfValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NoneOfValue Attribute Value",
				"While creating a NoneOfValue value, an extra attribute value was detected. "+
					"A NoneOfValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NoneOfValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNoneOfValueUnknown(), diags
	}

	optionalAttribute, ok := attributes["optional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`optional is missing from object`)

		return NewNoneOfValueUnknown(), diags
	}

	optionalVal, ok := optionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`optional expected to be basetypes.BoolValue, was: %T`, optionalAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return NewNoneOfValueUnknown(), diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.SetValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return NewNoneOfValueUnknown(), diags
	}

	return NoneOfValue{
		Optional: optionalVal,
		Values:   valuesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewNoneOfValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NoneOfValue {
	object, diags := NewNoneOfValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNoneOfValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NoneOfType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNoneOfValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNoneOfValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNoneOfValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNoneOfValueMust(NoneOfValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NoneOfType) ValueType(ctx context.Context) attr.Value {
	return NoneOfValue{}
}

var _ basetypes.ObjectValuable = NoneOfValue{}

type NoneOfValue struct {
	Optional basetypes.BoolValue `tfsdk:"optional"`
	Values   basetypes.SetValue  `tfsdk:"values"`
	state    attr.ValueState
}

func (v NoneOfValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["optional"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["values"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Optional.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["optional"] = val

		val, err = v.Values.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["values"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NoneOfValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NoneOfValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NoneOfValue) String() string {
	return "NoneOfValue"
}

func (v NoneOfValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valuesVal basetypes.SetValue
	switch {
	case v.Values.IsUnknown():
		valuesVal = types.SetUnknown(types.StringType)
	case v.Values.IsNull():
		valuesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		valuesVal, d = types.SetValue(types.StringType, v.Values.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"optional": basetypes.BoolType{},
			"values": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"optional": basetypes.BoolType{},
		"values": basetypes.SetType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"optional": v.Optional,
			"values":   valuesVal,
		})

	return objVal, diags
}

func (v NoneOfValue) Equal(o attr.Value) bool {
	other, ok := o.(NoneOfValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Optional.Equal(other.Optional) {
		return false
	}

	if !v.Values.Equal(other.Values) {
		return false
	}

	return true
}

func (v NoneOfValue) Type(ctx context.Context) attr.Type {
	return NoneOfType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NoneOfValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"optional": basetypes.BoolType{},
		"values": basetypes.SetType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = OneOfType{}

type OneOfType struct {
	basetypes.ObjectType
}

func (t OneOfType) Equal(o attr.Type) bool {
	other, ok := o.(OneOfType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OneOfType) String() string {
	return "OneOfType"
}

func (t OneOfType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	optionalAttribute, ok := attributes["optional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`optional is missing from object`)

		return nil, diags
	}

	optionalVal, ok := optionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`optional expected to be basetypes.BoolValue, was: %T`, optionalAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return nil, diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.SetValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OneOfValue{
		Optional: optionalVal,
		Values:   valuesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewOneOfValueNull() OneOfValue {
	return OneOfValue{
		state: attr.ValueStateNull,
	}
}

func NewOneOfValueUnknown() OneOfValue {
	return OneOfValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOneOfValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OneOfValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OneOfValue Attribute Value",
				"While creating a OneOfValue value, a missing attribute value was detected. "+
					"A OneOfValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OneOfValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OneOfValue Attribute Type",
				"While creating a OneOfValue value, an invalid attribute value was detected. "+
					"A OneOfValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OneOfValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OneOfValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OneOfValue Attribute Value",
				"While creating a OneOfValue value, an extra attribute value was detected. "+
					"A OneOfValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OneOfValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOneOfValueUnknown(), diags
	}

	optionalAttribute, ok := attributes["optional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`optional is missing from object`)

		return NewOneOfValueUnknown(), diags
	}

	optionalVal, ok := optionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`optional expected to be basetypes.BoolValue, was: %T`, optionalAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return NewOneOfValueUnknown(), diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.SetValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return NewOneOfValueUnknown(), diags
	}

	return OneOfValue{
		Optional: optionalVal,
		Values:   valuesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewOneOfValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OneOfValue {
	object, diags := NewOneOfValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOneOfValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OneOfType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOneOfValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOneOfValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOneOfValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOneOfValueMust(OneOfValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OneOfType) ValueType(ctx context.Context) attr.Value {
	return OneOfValue{}
}

var _ basetypes.ObjectValuable = OneOfValue{}

type OneOfValue struct {
	Optional basetypes.BoolValue `tfsdk:"optional"`
	Values   basetypes.SetValue  `tfsdk:"values"`
	state    attr.ValueState
}

func (v OneOfValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["optional"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["values"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Optional.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["optional"] = val

		val, err = v.Values.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["values"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OneOfValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OneOfValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OneOfValue) String() string {
	return "OneOfValue"
}

func (v OneOfValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valuesVal basetypes.SetValue
	switch {
	case v.Values.IsUnknown():
		valuesVal = types.SetUnknown(types.StringType)
	case v.Values.IsNull():
		valuesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		valuesVal, d = types.SetValue(types.StringType, v.Values.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"optional": basetypes.BoolType{},
			"values": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"optional": basetypes.BoolType{},
		"values": basetypes.SetType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"optional": v.Optional,
			"values":   valuesVal,
		})

	return objVal, diags
}

func (v OneOfValue) Equal(o attr.Value) bool {
	other, ok := o.(OneOfValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Optional.Equal(other.Optional) {
		return false
	}

	if !v.Values.Equal(other.Values) {
		return false
	}

	return true
}

func (v OneOfValue) Type(ctx context.Context) attr.Type {
	return OneOfType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OneOfValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"optional": basetypes.BoolType{},
		"values": basetypes.SetType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = RangeType{}

type RangeType struct {
	basetypes.ObjectType
}

func (t RangeType) Equal(o attr.Type) bool {
	other, ok := o.(RangeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RangeType) String() string {
	return "RangeType"
}

func (t RangeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maxAttribute, ok := attributes["max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max is missing from object`)

		return nil, diags
	}

	maxVal, ok := maxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max expected to be basetypes.Int64Value, was: %T`, maxAttribute))
	}

	minAttribute, ok := attributes["min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min is missing from object`)

		return nil, diags
	}

	minVal, ok := minAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min expected to be basetypes.Int64Value, was: %T`, minAttribute))
	}

	optionalAttribute, ok := attributes["optional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`optional is missing from object`)

		return nil, diags
	}

	optionalVal, ok := optionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`optional expected to be basetypes.BoolValue, was: %T`, optionalAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RangeValue{
		Max:      maxVal,
		Min:      minVal,
		Optional: optionalVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewRangeValueNull() RangeValue {
	return RangeValue{
		state: attr.ValueStateNull,
	}
}

func NewRangeValueUnknown() RangeValue {
	return RangeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRangeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RangeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RangeValue Attribute Value",
				"While creating a RangeValue value, a missing attribute value was detected. "+
					"A RangeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RangeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RangeValue Attribute Type",
				"While creating a RangeValue value, an invalid attribute value was detected. "+
					"A RangeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RangeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RangeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RangeValue Attribute Value",
				"While creating a RangeValue value, an extra attribute value was detected. "+
					"A RangeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RangeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRangeValueUnknown(), diags
	}

	maxAttribute, ok := attributes["max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max is missing from object`)

		return NewRangeValueUnknown(), diags
	}

	maxVal, ok := maxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max expected to be basetypes.Int64Value, was: %T`, maxAttribute))
	}

	minAttribute, ok := attributes["min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min is missing from object`)

		return NewRangeValueUnknown(), diags
	}

	minVal, ok := minAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min expected to be basetypes.Int64Value, was: %T`, minAttribute))
	}

	optionalAttribute, ok := attributes["optional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`optional is missing from object`)

		return NewRangeValueUnknown(), diags
	}

	optionalVal, ok := optionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`optional expected to be basetypes.BoolValue, was: %T`, optionalAttribute))
	}

	if diags.HasError() {
		return NewRangeValueUnknown(), diags
	}

	return RangeValue{
		Max:      maxVal,
		Min:      minVal,
		Optional: optionalVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewRangeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RangeValue {
	object, diags := NewRangeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRangeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RangeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRangeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRangeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRangeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRangeValueMust(RangeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RangeType) ValueType(ctx context.Context) attr.Value {
	return RangeValue{}
}

var _ basetypes.ObjectValuable = RangeValue{}

type RangeValue struct {
	Max      basetypes.Int64Value `tfsdk:"max"`
	Min      basetypes.Int64Value `tfsdk:"min"`
	Optional basetypes.BoolValue  `tfsdk:"optional"`
	state    attr.ValueState
}

func (v RangeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["optional"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Max.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max"] = val

		val, err = v.Min.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min"] = val

		val, err = v.Optional.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["optional"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RangeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RangeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RangeValue) String() string {
	return "RangeValue"
}

func (v RangeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"max":      basetypes.Int64Type{},
		"min":      basetypes.Int64Type{},
		"optional": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"max":      v.Max,
			"min":      v.Min,
			"optional": v.Optional,
		})

	return objVal, diags
}

func (v RangeValue) Equal(o attr.Value) bool {
	other, ok := o.(RangeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Max.Equal(other.Max) {
		return false
	}

	if !v.Min.Equal(other.Min) {
		return false
	}

	if !v.Optional.Equal(other.Optional) {
		return false
	}

	return true
}

func (v RangeValue) Type(ctx context.Context) attr.Type {
	return RangeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RangeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"max":      basetypes.Int64Type{},
		"min":      basetypes.Int64Type{},
		"optional": basetypes.BoolType{},
	}
}
