// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_console_partner_zone_v2

import (
	"context"
	"fmt"
	"github.com/conduktor/terraform-provider-conduktor/internal/schema/validation"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func ConsolePartnerZoneV2ResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"labels": schema.MapAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "Custom labels for the partner zone",
				MarkdownDescription: "Custom labels for the partner zone",
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "Partner Zone name, must be unique, acts as an ID for import",
				MarkdownDescription: "Partner Zone name, must be unique, acts as an ID for import",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^[0-9a-z\\_\\-]+$"), ""),
				},
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"authentication_mode": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"service_account": schema.StringAttribute{
								Required:            true,
								Description:         "Must be a Local Gateway Service Account. It doesn't need to exist before creating the Partner Zone. The service account will be created automatically",
								MarkdownDescription: "Must be a Local Gateway Service Account. It doesn't need to exist before creating the Partner Zone. The service account will be created automatically",
							},
							"type": schema.StringAttribute{
								Required:            true,
								Description:         "Authentication type for the partner zone. Valid values are: MTLS, OAUTHBEARER, PLAIN",
								MarkdownDescription: "Authentication type for the partner zone. Valid values are: MTLS, OAUTHBEARER, PLAIN",
								Validators: []validator.String{
									stringvalidator.OneOf(validation.ValidPartnerZoneAuthenticationType...),
								},
							},
						},
						CustomType: AuthenticationModeType{
							ObjectType: types.ObjectType{
								AttrTypes: AuthenticationModeValue{}.AttributeTypes(ctx),
							},
						},
						Required: true,
					},
					"cluster": schema.StringAttribute{
						Required:            true,
						Description:         "Cluster name linked with the partner zone. Must be a valid Console cluster with the Provider configured as Gateway",
						MarkdownDescription: "Cluster name linked with the partner zone. Must be a valid Console cluster with the Provider configured as Gateway",
					},
					"description": schema.StringAttribute{
						Optional:            true,
						Description:         "Description of the partner zone",
						MarkdownDescription: "Description of the partner zone",
					},
					"display_name": schema.StringAttribute{
						Optional:            true,
						Description:         "Display name of the partner zone",
						MarkdownDescription: "Display name of the partner zone",
					},
					"headers": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"add_on_produce": schema.SetNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"key": schema.StringAttribute{
											Required:            true,
											Description:         "Key to add to the request headers when producing messages to the topic",
											MarkdownDescription: "Key to add to the request headers when producing messages to the topic",
										},
										"override_if_exists": schema.BoolAttribute{
											Required:            true,
											Description:         "If set to true, the header will override any existing header with the same key",
											MarkdownDescription: "If set to true, the header will override any existing header with the same key",
										},
										"value": schema.StringAttribute{
											Required:            true,
											Description:         "Value to add to the request headers when producing messages to the topic",
											MarkdownDescription: "Value to add to the request headers when producing messages to the topic",
										},
									},
									CustomType: AddOnProduceType{
										ObjectType: types.ObjectType{
											AttrTypes: AddOnProduceValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Description:         "Sets a key-value pair to be added when producing to the partner zone",
								MarkdownDescription: "Sets a key-value pair to be added when producing to the partner zone",
							},
							"remove_on_consume": schema.SetNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"key_regex": schema.StringAttribute{
											Required:            true,
											Description:         "Must be a valid java regular expression",
											MarkdownDescription: "Must be a valid java regular expression",
										},
									},
									CustomType: RemoveOnConsumeType{
										ObjectType: types.ObjectType{
											AttrTypes: RemoveOnConsumeValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Description:         "Regular expression for finding the keys of headers to be removed on consume of the partner zone",
								MarkdownDescription: "Regular expression for finding the keys of headers to be removed on consume of the partner zone",
							},
						},
						CustomType: HeadersType{
							ObjectType: types.ObjectType{
								AttrTypes: HeadersValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Key-Value HTTP headers to add to requests",
						MarkdownDescription: "Key-Value HTTP headers to add to requests",
					},
					"partner": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"email": schema.StringAttribute{
								Optional:            true,
								Description:         "Email of the Partner",
								MarkdownDescription: "Email of the Partner",
							},
							"name": schema.StringAttribute{
								Required:            true,
								Description:         "Name of the Partner",
								MarkdownDescription: "Name of the Partner",
							},
							"phone": schema.StringAttribute{
								Optional:            true,
								Description:         "Phone number of the Partner",
								MarkdownDescription: "Phone number of the Partner",
							},
							"role": schema.StringAttribute{
								Optional:            true,
								Description:         "Role of the Partner",
								MarkdownDescription: "Role of the Partner",
							},
						},
						CustomType: PartnerType{
							ObjectType: types.ObjectType{
								AttrTypes: PartnerValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Partner information for the partner zone",
						MarkdownDescription: "Partner information for the partner zone",
					},
					"topics": schema.SetNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"backing_topic": schema.StringAttribute{
									Required:            true,
									Description:         "Internal name of the topic that you want to share with your partner",
									MarkdownDescription: "Internal name of the topic that you want to share with your partner",
								},
								"name": schema.StringAttribute{
									Required:            true,
									Description:         "Name of the topic as it should appear to your partner. This can be different from backing_topic",
									MarkdownDescription: "Name of the topic as it should appear to your partner. This can be different from backing_topic",
								},
								"permission": schema.StringAttribute{
									Required:            true,
									Description:         "Permission to apply on the topic for the partner. Valid values are: READ, WRITE",
									MarkdownDescription: "Permission to apply on the topic for the partner. Valid values are: READ, WRITE",
									Validators: []validator.String{
										stringvalidator.OneOf(validation.ValidPartnerZoneTopicPermission...),
									},
								},
							},
							CustomType: TopicsType{
								ObjectType: types.ObjectType{
									AttrTypes: TopicsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Required:            true,
						Description:         "Set of all topics to be exposed in the partner zone",
						MarkdownDescription: "Set of all topics to be exposed in the partner zone",
					},
					"traffic_control_policies": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"limit_commit_offset": schema.Int64Attribute{
								Optional:            true,
								Description:         "Sets the maximum number of commits requests (in requests/minute) that the partner can make per Gateway node.",
								MarkdownDescription: "Sets the maximum number of commits requests (in requests/minute) that the partner can make per Gateway node.",
							},
							"max_consume_rate": schema.Int64Attribute{
								Optional:            true,
								Description:         "Sets the maximum rate (in bytes/s) at which the partner can consume messages from the topics per Gateway node.",
								MarkdownDescription: "Sets the maximum rate (in bytes/s) at which the partner can consume messages from the topics per Gateway node.",
							},
							"max_produce_rate": schema.Int64Attribute{
								Optional:            true,
								Description:         "Sets the maximum rate (in bytes/s) at which the partner can produce messages to the topics per Gateway node.",
								MarkdownDescription: "Sets the maximum rate (in bytes/s) at which the partner can produce messages to the topics per Gateway node.",
							},
						},
						CustomType: TrafficControlPoliciesType{
							ObjectType: types.ObjectType{
								AttrTypes: TrafficControlPoliciesValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Traffic control policies for the partner zone",
						MarkdownDescription: "Traffic control policies for the partner zone",
					},
					"url": schema.StringAttribute{
						Optional:            true,
						Description:         "URL of the partner zone",
						MarkdownDescription: "URL of the partner zone",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "Partner Zone specification",
				MarkdownDescription: "Partner Zone specification",
			},
		},
	}
}

type ConsolePartnerZoneV2Model struct {
	Labels types.Map    `tfsdk:"labels"`
	Name   types.String `tfsdk:"name"`
	Spec   SpecValue    `tfsdk:"spec"`
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authenticationModeAttribute, ok := attributes["authentication_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authentication_mode is missing from object`)

		return nil, diags
	}

	authenticationModeVal, ok := authenticationModeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authentication_mode expected to be basetypes.ObjectValue, was: %T`, authenticationModeAttribute))
	}

	clusterAttribute, ok := attributes["cluster"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster is missing from object`)

		return nil, diags
	}

	clusterVal, ok := clusterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster expected to be basetypes.StringValue, was: %T`, clusterAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	headersAttribute, ok := attributes["headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`headers is missing from object`)

		return nil, diags
	}

	headersVal, ok := headersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`headers expected to be basetypes.ObjectValue, was: %T`, headersAttribute))
	}

	partnerAttribute, ok := attributes["partner"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`partner is missing from object`)

		return nil, diags
	}

	partnerVal, ok := partnerAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`partner expected to be basetypes.ObjectValue, was: %T`, partnerAttribute))
	}

	topicsAttribute, ok := attributes["topics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`topics is missing from object`)

		return nil, diags
	}

	topicsVal, ok := topicsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`topics expected to be basetypes.SetValue, was: %T`, topicsAttribute))
	}

	trafficControlPoliciesAttribute, ok := attributes["traffic_control_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`traffic_control_policies is missing from object`)

		return nil, diags
	}

	trafficControlPoliciesVal, ok := trafficControlPoliciesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`traffic_control_policies expected to be basetypes.ObjectValue, was: %T`, trafficControlPoliciesAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		AuthenticationMode:     authenticationModeVal,
		Cluster:                clusterVal,
		Description:            descriptionVal,
		DisplayName:            displayNameVal,
		Headers:                headersVal,
		Partner:                partnerVal,
		Topics:                 topicsVal,
		TrafficControlPolicies: trafficControlPoliciesVal,
		Url:                    urlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	authenticationModeAttribute, ok := attributes["authentication_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authentication_mode is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	authenticationModeVal, ok := authenticationModeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authentication_mode expected to be basetypes.ObjectValue, was: %T`, authenticationModeAttribute))
	}

	clusterAttribute, ok := attributes["cluster"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	clusterVal, ok := clusterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster expected to be basetypes.StringValue, was: %T`, clusterAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	headersAttribute, ok := attributes["headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`headers is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	headersVal, ok := headersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`headers expected to be basetypes.ObjectValue, was: %T`, headersAttribute))
	}

	partnerAttribute, ok := attributes["partner"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`partner is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	partnerVal, ok := partnerAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`partner expected to be basetypes.ObjectValue, was: %T`, partnerAttribute))
	}

	topicsAttribute, ok := attributes["topics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`topics is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	topicsVal, ok := topicsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`topics expected to be basetypes.SetValue, was: %T`, topicsAttribute))
	}

	trafficControlPoliciesAttribute, ok := attributes["traffic_control_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`traffic_control_policies is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	trafficControlPoliciesVal, ok := trafficControlPoliciesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`traffic_control_policies expected to be basetypes.ObjectValue, was: %T`, trafficControlPoliciesAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		AuthenticationMode:     authenticationModeVal,
		Cluster:                clusterVal,
		Description:            descriptionVal,
		DisplayName:            displayNameVal,
		Headers:                headersVal,
		Partner:                partnerVal,
		Topics:                 topicsVal,
		TrafficControlPolicies: trafficControlPoliciesVal,
		Url:                    urlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	AuthenticationMode     basetypes.ObjectValue `tfsdk:"authentication_mode"`
	Cluster                basetypes.StringValue `tfsdk:"cluster"`
	Description            basetypes.StringValue `tfsdk:"description"`
	DisplayName            basetypes.StringValue `tfsdk:"display_name"`
	Headers                basetypes.ObjectValue `tfsdk:"headers"`
	Partner                basetypes.ObjectValue `tfsdk:"partner"`
	Topics                 basetypes.SetValue    `tfsdk:"topics"`
	TrafficControlPolicies basetypes.ObjectValue `tfsdk:"traffic_control_policies"`
	Url                    basetypes.StringValue `tfsdk:"url"`
	state                  attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["authentication_mode"] = basetypes.ObjectType{
		AttrTypes: AuthenticationModeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["cluster"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["headers"] = basetypes.ObjectType{
		AttrTypes: HeadersValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["partner"] = basetypes.ObjectType{
		AttrTypes: PartnerValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["topics"] = basetypes.SetType{
		ElemType: TopicsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["traffic_control_policies"] = basetypes.ObjectType{
		AttrTypes: TrafficControlPoliciesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.AuthenticationMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authentication_mode"] = val

		val, err = v.Cluster.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.Headers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["headers"] = val

		val, err = v.Partner.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["partner"] = val

		val, err = v.Topics.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["topics"] = val

		val, err = v.TrafficControlPolicies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["traffic_control_policies"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var authenticationModeVal basetypes.ObjectValue

	if v.AuthenticationMode.IsNull() {
		authenticationModeVal = types.ObjectNull(
			AuthenticationModeValue{}.AttributeTypes(ctx),
		)
	}

	if v.AuthenticationMode.IsUnknown() {
		authenticationModeVal = types.ObjectUnknown(
			AuthenticationModeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AuthenticationMode.IsNull() && !v.AuthenticationMode.IsUnknown() {
		authenticationModeVal = types.ObjectValueMust(
			AuthenticationModeValue{}.AttributeTypes(ctx),
			v.AuthenticationMode.Attributes(),
		)
	}

	var headersVal basetypes.ObjectValue

	if v.Headers.IsNull() {
		headersVal = types.ObjectNull(
			HeadersValue{}.AttributeTypes(ctx),
		)
	}

	if v.Headers.IsUnknown() {
		headersVal = types.ObjectUnknown(
			HeadersValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Headers.IsNull() && !v.Headers.IsUnknown() {
		headersVal = types.ObjectValueMust(
			HeadersValue{}.AttributeTypes(ctx),
			v.Headers.Attributes(),
		)
	}

	var partnerVal basetypes.ObjectValue

	if v.Partner.IsNull() {
		partnerVal = types.ObjectNull(
			PartnerValue{}.AttributeTypes(ctx),
		)
	}

	if v.Partner.IsUnknown() {
		partnerVal = types.ObjectUnknown(
			PartnerValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Partner.IsNull() && !v.Partner.IsUnknown() {
		partnerVal = types.ObjectValueMust(
			PartnerValue{}.AttributeTypes(ctx),
			v.Partner.Attributes(),
		)
	}

	topics := types.SetValueMust(
		TopicsType{
			basetypes.ObjectType{
				AttrTypes: TopicsValue{}.AttributeTypes(ctx),
			},
		},
		v.Topics.Elements(),
	)

	if v.Topics.IsNull() {
		topics = types.SetNull(
			TopicsType{
				basetypes.ObjectType{
					AttrTypes: TopicsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Topics.IsUnknown() {
		topics = types.SetUnknown(
			TopicsType{
				basetypes.ObjectType{
					AttrTypes: TopicsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var trafficControlPoliciesVal basetypes.ObjectValue

	if v.TrafficControlPolicies.IsNull() {
		trafficControlPoliciesVal = types.ObjectNull(
			TrafficControlPoliciesValue{}.AttributeTypes(ctx),
		)
	}

	if v.TrafficControlPolicies.IsUnknown() {
		trafficControlPoliciesVal = types.ObjectUnknown(
			TrafficControlPoliciesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.TrafficControlPolicies.IsNull() && !v.TrafficControlPolicies.IsUnknown() {
		trafficControlPoliciesVal = types.ObjectValueMust(
			TrafficControlPoliciesValue{}.AttributeTypes(ctx),
			v.TrafficControlPolicies.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"authentication_mode": basetypes.ObjectType{
			AttrTypes: AuthenticationModeValue{}.AttributeTypes(ctx),
		},
		"cluster":      basetypes.StringType{},
		"description":  basetypes.StringType{},
		"display_name": basetypes.StringType{},
		"headers": basetypes.ObjectType{
			AttrTypes: HeadersValue{}.AttributeTypes(ctx),
		},
		"partner": basetypes.ObjectType{
			AttrTypes: PartnerValue{}.AttributeTypes(ctx),
		},
		"topics": basetypes.SetType{
			ElemType: TopicsValue{}.Type(ctx),
		},
		"traffic_control_policies": basetypes.ObjectType{
			AttrTypes: TrafficControlPoliciesValue{}.AttributeTypes(ctx),
		},
		"url": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"authentication_mode":      authenticationModeVal,
			"cluster":                  v.Cluster,
			"description":              v.Description,
			"display_name":             v.DisplayName,
			"headers":                  headersVal,
			"partner":                  partnerVal,
			"topics":                   topics,
			"traffic_control_policies": trafficControlPoliciesVal,
			"url":                      v.Url,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AuthenticationMode.Equal(other.AuthenticationMode) {
		return false
	}

	if !v.Cluster.Equal(other.Cluster) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.Headers.Equal(other.Headers) {
		return false
	}

	if !v.Partner.Equal(other.Partner) {
		return false
	}

	if !v.Topics.Equal(other.Topics) {
		return false
	}

	if !v.TrafficControlPolicies.Equal(other.TrafficControlPolicies) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"authentication_mode": basetypes.ObjectType{
			AttrTypes: AuthenticationModeValue{}.AttributeTypes(ctx),
		},
		"cluster":      basetypes.StringType{},
		"description":  basetypes.StringType{},
		"display_name": basetypes.StringType{},
		"headers": basetypes.ObjectType{
			AttrTypes: HeadersValue{}.AttributeTypes(ctx),
		},
		"partner": basetypes.ObjectType{
			AttrTypes: PartnerValue{}.AttributeTypes(ctx),
		},
		"topics": basetypes.SetType{
			ElemType: TopicsValue{}.Type(ctx),
		},
		"traffic_control_policies": basetypes.ObjectType{
			AttrTypes: TrafficControlPoliciesValue{}.AttributeTypes(ctx),
		},
		"url": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AuthenticationModeType{}

type AuthenticationModeType struct {
	basetypes.ObjectType
}

func (t AuthenticationModeType) Equal(o attr.Type) bool {
	other, ok := o.(AuthenticationModeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthenticationModeType) String() string {
	return "AuthenticationModeType"
}

func (t AuthenticationModeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	serviceAccountAttribute, ok := attributes["service_account"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_account is missing from object`)

		return nil, diags
	}

	serviceAccountVal, ok := serviceAccountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_account expected to be basetypes.StringValue, was: %T`, serviceAccountAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthenticationModeValue{
		ServiceAccount:         serviceAccountVal,
		AuthenticationModeType: typeVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewAuthenticationModeValueNull() AuthenticationModeValue {
	return AuthenticationModeValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthenticationModeValueUnknown() AuthenticationModeValue {
	return AuthenticationModeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthenticationModeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthenticationModeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthenticationModeValue Attribute Value",
				"While creating a AuthenticationModeValue value, a missing attribute value was detected. "+
					"A AuthenticationModeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthenticationModeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthenticationModeValue Attribute Type",
				"While creating a AuthenticationModeValue value, an invalid attribute value was detected. "+
					"A AuthenticationModeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthenticationModeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthenticationModeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthenticationModeValue Attribute Value",
				"While creating a AuthenticationModeValue value, an extra attribute value was detected. "+
					"A AuthenticationModeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthenticationModeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthenticationModeValueUnknown(), diags
	}

	serviceAccountAttribute, ok := attributes["service_account"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_account is missing from object`)

		return NewAuthenticationModeValueUnknown(), diags
	}

	serviceAccountVal, ok := serviceAccountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_account expected to be basetypes.StringValue, was: %T`, serviceAccountAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewAuthenticationModeValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewAuthenticationModeValueUnknown(), diags
	}

	return AuthenticationModeValue{
		ServiceAccount:         serviceAccountVal,
		AuthenticationModeType: typeVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewAuthenticationModeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthenticationModeValue {
	object, diags := NewAuthenticationModeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthenticationModeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthenticationModeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthenticationModeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthenticationModeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthenticationModeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthenticationModeValueMust(AuthenticationModeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthenticationModeType) ValueType(ctx context.Context) attr.Value {
	return AuthenticationModeValue{}
}

var _ basetypes.ObjectValuable = AuthenticationModeValue{}

type AuthenticationModeValue struct {
	ServiceAccount         basetypes.StringValue `tfsdk:"service_account"`
	AuthenticationModeType basetypes.StringValue `tfsdk:"type"`
	state                  attr.ValueState
}

func (v AuthenticationModeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["service_account"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ServiceAccount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_account"] = val

		val, err = v.AuthenticationModeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthenticationModeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthenticationModeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthenticationModeValue) String() string {
	return "AuthenticationModeValue"
}

func (v AuthenticationModeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"service_account": basetypes.StringType{},
		"type":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"service_account": v.ServiceAccount,
			"type":            v.AuthenticationModeType,
		})

	return objVal, diags
}

func (v AuthenticationModeValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthenticationModeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ServiceAccount.Equal(other.ServiceAccount) {
		return false
	}

	if !v.AuthenticationModeType.Equal(other.AuthenticationModeType) {
		return false
	}

	return true
}

func (v AuthenticationModeValue) Type(ctx context.Context) attr.Type {
	return AuthenticationModeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthenticationModeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"service_account": basetypes.StringType{},
		"type":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = HeadersType{}

type HeadersType struct {
	basetypes.ObjectType
}

func (t HeadersType) Equal(o attr.Type) bool {
	other, ok := o.(HeadersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t HeadersType) String() string {
	return "HeadersType"
}

func (t HeadersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addOnProduceAttribute, ok := attributes["add_on_produce"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add_on_produce is missing from object`)

		return nil, diags
	}

	addOnProduceVal, ok := addOnProduceAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add_on_produce expected to be basetypes.SetValue, was: %T`, addOnProduceAttribute))
	}

	removeOnConsumeAttribute, ok := attributes["remove_on_consume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_on_consume is missing from object`)

		return nil, diags
	}

	removeOnConsumeVal, ok := removeOnConsumeAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_on_consume expected to be basetypes.SetValue, was: %T`, removeOnConsumeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return HeadersValue{
		AddOnProduce:    addOnProduceVal,
		RemoveOnConsume: removeOnConsumeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewHeadersValueNull() HeadersValue {
	return HeadersValue{
		state: attr.ValueStateNull,
	}
}

func NewHeadersValueUnknown() HeadersValue {
	return HeadersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewHeadersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (HeadersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing HeadersValue Attribute Value",
				"While creating a HeadersValue value, a missing attribute value was detected. "+
					"A HeadersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HeadersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid HeadersValue Attribute Type",
				"While creating a HeadersValue value, an invalid attribute value was detected. "+
					"A HeadersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HeadersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("HeadersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra HeadersValue Attribute Value",
				"While creating a HeadersValue value, an extra attribute value was detected. "+
					"A HeadersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra HeadersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHeadersValueUnknown(), diags
	}

	addOnProduceAttribute, ok := attributes["add_on_produce"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add_on_produce is missing from object`)

		return NewHeadersValueUnknown(), diags
	}

	addOnProduceVal, ok := addOnProduceAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add_on_produce expected to be basetypes.SetValue, was: %T`, addOnProduceAttribute))
	}

	removeOnConsumeAttribute, ok := attributes["remove_on_consume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_on_consume is missing from object`)

		return NewHeadersValueUnknown(), diags
	}

	removeOnConsumeVal, ok := removeOnConsumeAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_on_consume expected to be basetypes.SetValue, was: %T`, removeOnConsumeAttribute))
	}

	if diags.HasError() {
		return NewHeadersValueUnknown(), diags
	}

	return HeadersValue{
		AddOnProduce:    addOnProduceVal,
		RemoveOnConsume: removeOnConsumeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewHeadersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) HeadersValue {
	object, diags := NewHeadersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHeadersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t HeadersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHeadersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHeadersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHeadersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHeadersValueMust(HeadersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t HeadersType) ValueType(ctx context.Context) attr.Value {
	return HeadersValue{}
}

var _ basetypes.ObjectValuable = HeadersValue{}

type HeadersValue struct {
	AddOnProduce    basetypes.SetValue `tfsdk:"add_on_produce"`
	RemoveOnConsume basetypes.SetValue `tfsdk:"remove_on_consume"`
	state           attr.ValueState
}

func (v HeadersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["add_on_produce"] = basetypes.SetType{
		ElemType: AddOnProduceValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["remove_on_consume"] = basetypes.SetType{
		ElemType: RemoveOnConsumeValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AddOnProduce.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["add_on_produce"] = val

		val, err = v.RemoveOnConsume.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remove_on_consume"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v HeadersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v HeadersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v HeadersValue) String() string {
	return "HeadersValue"
}

func (v HeadersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	addOnProduce := types.SetValueMust(
		AddOnProduceType{
			basetypes.ObjectType{
				AttrTypes: AddOnProduceValue{}.AttributeTypes(ctx),
			},
		},
		v.AddOnProduce.Elements(),
	)

	if v.AddOnProduce.IsNull() {
		addOnProduce = types.SetNull(
			AddOnProduceType{
				basetypes.ObjectType{
					AttrTypes: AddOnProduceValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AddOnProduce.IsUnknown() {
		addOnProduce = types.SetUnknown(
			AddOnProduceType{
				basetypes.ObjectType{
					AttrTypes: AddOnProduceValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	removeOnConsume := types.SetValueMust(
		RemoveOnConsumeType{
			basetypes.ObjectType{
				AttrTypes: RemoveOnConsumeValue{}.AttributeTypes(ctx),
			},
		},
		v.RemoveOnConsume.Elements(),
	)

	if v.RemoveOnConsume.IsNull() {
		removeOnConsume = types.SetNull(
			RemoveOnConsumeType{
				basetypes.ObjectType{
					AttrTypes: RemoveOnConsumeValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.RemoveOnConsume.IsUnknown() {
		removeOnConsume = types.SetUnknown(
			RemoveOnConsumeType{
				basetypes.ObjectType{
					AttrTypes: RemoveOnConsumeValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"add_on_produce": basetypes.SetType{
			ElemType: AddOnProduceValue{}.Type(ctx),
		},
		"remove_on_consume": basetypes.SetType{
			ElemType: RemoveOnConsumeValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"add_on_produce":    addOnProduce,
			"remove_on_consume": removeOnConsume,
		})

	return objVal, diags
}

func (v HeadersValue) Equal(o attr.Value) bool {
	other, ok := o.(HeadersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AddOnProduce.Equal(other.AddOnProduce) {
		return false
	}

	if !v.RemoveOnConsume.Equal(other.RemoveOnConsume) {
		return false
	}

	return true
}

func (v HeadersValue) Type(ctx context.Context) attr.Type {
	return HeadersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v HeadersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"add_on_produce": basetypes.SetType{
			ElemType: AddOnProduceValue{}.Type(ctx),
		},
		"remove_on_consume": basetypes.SetType{
			ElemType: RemoveOnConsumeValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AddOnProduceType{}

type AddOnProduceType struct {
	basetypes.ObjectType
}

func (t AddOnProduceType) Equal(o attr.Type) bool {
	other, ok := o.(AddOnProduceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AddOnProduceType) String() string {
	return "AddOnProduceType"
}

func (t AddOnProduceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	overrideIfExistsAttribute, ok := attributes["override_if_exists"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`override_if_exists is missing from object`)

		return nil, diags
	}

	overrideIfExistsVal, ok := overrideIfExistsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`override_if_exists expected to be basetypes.BoolValue, was: %T`, overrideIfExistsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AddOnProduceValue{
		Key:              keyVal,
		OverrideIfExists: overrideIfExistsVal,
		Value:            valueVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAddOnProduceValueNull() AddOnProduceValue {
	return AddOnProduceValue{
		state: attr.ValueStateNull,
	}
}

func NewAddOnProduceValueUnknown() AddOnProduceValue {
	return AddOnProduceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAddOnProduceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AddOnProduceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AddOnProduceValue Attribute Value",
				"While creating a AddOnProduceValue value, a missing attribute value was detected. "+
					"A AddOnProduceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AddOnProduceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AddOnProduceValue Attribute Type",
				"While creating a AddOnProduceValue value, an invalid attribute value was detected. "+
					"A AddOnProduceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AddOnProduceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AddOnProduceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AddOnProduceValue Attribute Value",
				"While creating a AddOnProduceValue value, an extra attribute value was detected. "+
					"A AddOnProduceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AddOnProduceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAddOnProduceValueUnknown(), diags
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewAddOnProduceValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	overrideIfExistsAttribute, ok := attributes["override_if_exists"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`override_if_exists is missing from object`)

		return NewAddOnProduceValueUnknown(), diags
	}

	overrideIfExistsVal, ok := overrideIfExistsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`override_if_exists expected to be basetypes.BoolValue, was: %T`, overrideIfExistsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewAddOnProduceValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewAddOnProduceValueUnknown(), diags
	}

	return AddOnProduceValue{
		Key:              keyVal,
		OverrideIfExists: overrideIfExistsVal,
		Value:            valueVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAddOnProduceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AddOnProduceValue {
	object, diags := NewAddOnProduceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAddOnProduceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AddOnProduceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAddOnProduceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAddOnProduceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAddOnProduceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAddOnProduceValueMust(AddOnProduceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AddOnProduceType) ValueType(ctx context.Context) attr.Value {
	return AddOnProduceValue{}
}

var _ basetypes.ObjectValuable = AddOnProduceValue{}

type AddOnProduceValue struct {
	Key              basetypes.StringValue `tfsdk:"key"`
	OverrideIfExists basetypes.BoolValue   `tfsdk:"override_if_exists"`
	Value            basetypes.StringValue `tfsdk:"value"`
	state            attr.ValueState
}

func (v AddOnProduceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["override_if_exists"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.OverrideIfExists.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["override_if_exists"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AddOnProduceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AddOnProduceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AddOnProduceValue) String() string {
	return "AddOnProduceValue"
}

func (v AddOnProduceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"key":                basetypes.StringType{},
		"override_if_exists": basetypes.BoolType{},
		"value":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"key":                v.Key,
			"override_if_exists": v.OverrideIfExists,
			"value":              v.Value,
		})

	return objVal, diags
}

func (v AddOnProduceValue) Equal(o attr.Value) bool {
	other, ok := o.(AddOnProduceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.OverrideIfExists.Equal(other.OverrideIfExists) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v AddOnProduceValue) Type(ctx context.Context) attr.Type {
	return AddOnProduceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AddOnProduceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"key":                basetypes.StringType{},
		"override_if_exists": basetypes.BoolType{},
		"value":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RemoveOnConsumeType{}

type RemoveOnConsumeType struct {
	basetypes.ObjectType
}

func (t RemoveOnConsumeType) Equal(o attr.Type) bool {
	other, ok := o.(RemoveOnConsumeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RemoveOnConsumeType) String() string {
	return "RemoveOnConsumeType"
}

func (t RemoveOnConsumeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	keyRegexAttribute, ok := attributes["key_regex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key_regex is missing from object`)

		return nil, diags
	}

	keyRegexVal, ok := keyRegexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key_regex expected to be basetypes.StringValue, was: %T`, keyRegexAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RemoveOnConsumeValue{
		KeyRegex: keyRegexVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewRemoveOnConsumeValueNull() RemoveOnConsumeValue {
	return RemoveOnConsumeValue{
		state: attr.ValueStateNull,
	}
}

func NewRemoveOnConsumeValueUnknown() RemoveOnConsumeValue {
	return RemoveOnConsumeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRemoveOnConsumeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RemoveOnConsumeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RemoveOnConsumeValue Attribute Value",
				"While creating a RemoveOnConsumeValue value, a missing attribute value was detected. "+
					"A RemoveOnConsumeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoveOnConsumeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RemoveOnConsumeValue Attribute Type",
				"While creating a RemoveOnConsumeValue value, an invalid attribute value was detected. "+
					"A RemoveOnConsumeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoveOnConsumeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RemoveOnConsumeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RemoveOnConsumeValue Attribute Value",
				"While creating a RemoveOnConsumeValue value, an extra attribute value was detected. "+
					"A RemoveOnConsumeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RemoveOnConsumeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRemoveOnConsumeValueUnknown(), diags
	}

	keyRegexAttribute, ok := attributes["key_regex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key_regex is missing from object`)

		return NewRemoveOnConsumeValueUnknown(), diags
	}

	keyRegexVal, ok := keyRegexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key_regex expected to be basetypes.StringValue, was: %T`, keyRegexAttribute))
	}

	if diags.HasError() {
		return NewRemoveOnConsumeValueUnknown(), diags
	}

	return RemoveOnConsumeValue{
		KeyRegex: keyRegexVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewRemoveOnConsumeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RemoveOnConsumeValue {
	object, diags := NewRemoveOnConsumeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRemoveOnConsumeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RemoveOnConsumeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRemoveOnConsumeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRemoveOnConsumeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRemoveOnConsumeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRemoveOnConsumeValueMust(RemoveOnConsumeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RemoveOnConsumeType) ValueType(ctx context.Context) attr.Value {
	return RemoveOnConsumeValue{}
}

var _ basetypes.ObjectValuable = RemoveOnConsumeValue{}

type RemoveOnConsumeValue struct {
	KeyRegex basetypes.StringValue `tfsdk:"key_regex"`
	state    attr.ValueState
}

func (v RemoveOnConsumeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["key_regex"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.KeyRegex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key_regex"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RemoveOnConsumeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RemoveOnConsumeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RemoveOnConsumeValue) String() string {
	return "RemoveOnConsumeValue"
}

func (v RemoveOnConsumeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"key_regex": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"key_regex": v.KeyRegex,
		})

	return objVal, diags
}

func (v RemoveOnConsumeValue) Equal(o attr.Value) bool {
	other, ok := o.(RemoveOnConsumeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.KeyRegex.Equal(other.KeyRegex) {
		return false
	}

	return true
}

func (v RemoveOnConsumeValue) Type(ctx context.Context) attr.Type {
	return RemoveOnConsumeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RemoveOnConsumeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"key_regex": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PartnerType{}

type PartnerType struct {
	basetypes.ObjectType
}

func (t PartnerType) Equal(o attr.Type) bool {
	other, ok := o.(PartnerType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PartnerType) String() string {
	return "PartnerType"
}

func (t PartnerType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return nil, diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	phoneAttribute, ok := attributes["phone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phone is missing from object`)

		return nil, diags
	}

	phoneVal, ok := phoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phone expected to be basetypes.StringValue, was: %T`, phoneAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return nil, diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PartnerValue{
		Email: emailVal,
		Name:  nameVal,
		Phone: phoneVal,
		Role:  roleVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPartnerValueNull() PartnerValue {
	return PartnerValue{
		state: attr.ValueStateNull,
	}
}

func NewPartnerValueUnknown() PartnerValue {
	return PartnerValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPartnerValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PartnerValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PartnerValue Attribute Value",
				"While creating a PartnerValue value, a missing attribute value was detected. "+
					"A PartnerValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PartnerValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PartnerValue Attribute Type",
				"While creating a PartnerValue value, an invalid attribute value was detected. "+
					"A PartnerValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PartnerValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PartnerValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PartnerValue Attribute Value",
				"While creating a PartnerValue value, an extra attribute value was detected. "+
					"A PartnerValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PartnerValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPartnerValueUnknown(), diags
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return NewPartnerValueUnknown(), diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPartnerValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	phoneAttribute, ok := attributes["phone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phone is missing from object`)

		return NewPartnerValueUnknown(), diags
	}

	phoneVal, ok := phoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phone expected to be basetypes.StringValue, was: %T`, phoneAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return NewPartnerValueUnknown(), diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	if diags.HasError() {
		return NewPartnerValueUnknown(), diags
	}

	return PartnerValue{
		Email: emailVal,
		Name:  nameVal,
		Phone: phoneVal,
		Role:  roleVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPartnerValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PartnerValue {
	object, diags := NewPartnerValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPartnerValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PartnerType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPartnerValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPartnerValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPartnerValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPartnerValueMust(PartnerValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PartnerType) ValueType(ctx context.Context) attr.Value {
	return PartnerValue{}
}

var _ basetypes.ObjectValuable = PartnerValue{}

type PartnerValue struct {
	Email basetypes.StringValue `tfsdk:"email"`
	Name  basetypes.StringValue `tfsdk:"name"`
	Phone basetypes.StringValue `tfsdk:"phone"`
	Role  basetypes.StringValue `tfsdk:"role"`
	state attr.ValueState
}

func (v PartnerValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["email"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["phone"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["role"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Email.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["email"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Phone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["phone"] = val

		val, err = v.Role.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PartnerValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PartnerValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PartnerValue) String() string {
	return "PartnerValue"
}

func (v PartnerValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"email": basetypes.StringType{},
		"name":  basetypes.StringType{},
		"phone": basetypes.StringType{},
		"role":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"email": v.Email,
			"name":  v.Name,
			"phone": v.Phone,
			"role":  v.Role,
		})

	return objVal, diags
}

func (v PartnerValue) Equal(o attr.Value) bool {
	other, ok := o.(PartnerValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Email.Equal(other.Email) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Phone.Equal(other.Phone) {
		return false
	}

	if !v.Role.Equal(other.Role) {
		return false
	}

	return true
}

func (v PartnerValue) Type(ctx context.Context) attr.Type {
	return PartnerType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PartnerValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"email": basetypes.StringType{},
		"name":  basetypes.StringType{},
		"phone": basetypes.StringType{},
		"role":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TopicsType{}

type TopicsType struct {
	basetypes.ObjectType
}

func (t TopicsType) Equal(o attr.Type) bool {
	other, ok := o.(TopicsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TopicsType) String() string {
	return "TopicsType"
}

func (t TopicsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backingTopicAttribute, ok := attributes["backing_topic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backing_topic is missing from object`)

		return nil, diags
	}

	backingTopicVal, ok := backingTopicAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backing_topic expected to be basetypes.StringValue, was: %T`, backingTopicAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	permissionAttribute, ok := attributes["permission"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission is missing from object`)

		return nil, diags
	}

	permissionVal, ok := permissionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission expected to be basetypes.StringValue, was: %T`, permissionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TopicsValue{
		BackingTopic: backingTopicVal,
		Name:         nameVal,
		Permission:   permissionVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewTopicsValueNull() TopicsValue {
	return TopicsValue{
		state: attr.ValueStateNull,
	}
}

func NewTopicsValueUnknown() TopicsValue {
	return TopicsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTopicsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TopicsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TopicsValue Attribute Value",
				"While creating a TopicsValue value, a missing attribute value was detected. "+
					"A TopicsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TopicsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TopicsValue Attribute Type",
				"While creating a TopicsValue value, an invalid attribute value was detected. "+
					"A TopicsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TopicsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TopicsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TopicsValue Attribute Value",
				"While creating a TopicsValue value, an extra attribute value was detected. "+
					"A TopicsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TopicsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTopicsValueUnknown(), diags
	}

	backingTopicAttribute, ok := attributes["backing_topic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backing_topic is missing from object`)

		return NewTopicsValueUnknown(), diags
	}

	backingTopicVal, ok := backingTopicAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backing_topic expected to be basetypes.StringValue, was: %T`, backingTopicAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTopicsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	permissionAttribute, ok := attributes["permission"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission is missing from object`)

		return NewTopicsValueUnknown(), diags
	}

	permissionVal, ok := permissionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission expected to be basetypes.StringValue, was: %T`, permissionAttribute))
	}

	if diags.HasError() {
		return NewTopicsValueUnknown(), diags
	}

	return TopicsValue{
		BackingTopic: backingTopicVal,
		Name:         nameVal,
		Permission:   permissionVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewTopicsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TopicsValue {
	object, diags := NewTopicsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTopicsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TopicsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTopicsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTopicsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTopicsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTopicsValueMust(TopicsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TopicsType) ValueType(ctx context.Context) attr.Value {
	return TopicsValue{}
}

var _ basetypes.ObjectValuable = TopicsValue{}

type TopicsValue struct {
	BackingTopic basetypes.StringValue `tfsdk:"backing_topic"`
	Name         basetypes.StringValue `tfsdk:"name"`
	Permission   basetypes.StringValue `tfsdk:"permission"`
	state        attr.ValueState
}

func (v TopicsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["backing_topic"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["permission"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.BackingTopic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backing_topic"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Permission.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["permission"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TopicsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TopicsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TopicsValue) String() string {
	return "TopicsValue"
}

func (v TopicsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"backing_topic": basetypes.StringType{},
		"name":          basetypes.StringType{},
		"permission":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backing_topic": v.BackingTopic,
			"name":          v.Name,
			"permission":    v.Permission,
		})

	return objVal, diags
}

func (v TopicsValue) Equal(o attr.Value) bool {
	other, ok := o.(TopicsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BackingTopic.Equal(other.BackingTopic) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Permission.Equal(other.Permission) {
		return false
	}

	return true
}

func (v TopicsValue) Type(ctx context.Context) attr.Type {
	return TopicsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TopicsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backing_topic": basetypes.StringType{},
		"name":          basetypes.StringType{},
		"permission":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TrafficControlPoliciesType{}

type TrafficControlPoliciesType struct {
	basetypes.ObjectType
}

func (t TrafficControlPoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(TrafficControlPoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TrafficControlPoliciesType) String() string {
	return "TrafficControlPoliciesType"
}

func (t TrafficControlPoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	limitCommitOffsetAttribute, ok := attributes["limit_commit_offset"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit_commit_offset is missing from object`)

		return nil, diags
	}

	limitCommitOffsetVal, ok := limitCommitOffsetAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit_commit_offset expected to be basetypes.Int64Value, was: %T`, limitCommitOffsetAttribute))
	}

	maxConsumeRateAttribute, ok := attributes["max_consume_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_consume_rate is missing from object`)

		return nil, diags
	}

	maxConsumeRateVal, ok := maxConsumeRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_consume_rate expected to be basetypes.Int64Value, was: %T`, maxConsumeRateAttribute))
	}

	maxProduceRateAttribute, ok := attributes["max_produce_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_produce_rate is missing from object`)

		return nil, diags
	}

	maxProduceRateVal, ok := maxProduceRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_produce_rate expected to be basetypes.Int64Value, was: %T`, maxProduceRateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TrafficControlPoliciesValue{
		LimitCommitOffset: limitCommitOffsetVal,
		MaxConsumeRate:    maxConsumeRateVal,
		MaxProduceRate:    maxProduceRateVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTrafficControlPoliciesValueNull() TrafficControlPoliciesValue {
	return TrafficControlPoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewTrafficControlPoliciesValueUnknown() TrafficControlPoliciesValue {
	return TrafficControlPoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTrafficControlPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TrafficControlPoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TrafficControlPoliciesValue Attribute Value",
				"While creating a TrafficControlPoliciesValue value, a missing attribute value was detected. "+
					"A TrafficControlPoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficControlPoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TrafficControlPoliciesValue Attribute Type",
				"While creating a TrafficControlPoliciesValue value, an invalid attribute value was detected. "+
					"A TrafficControlPoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficControlPoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TrafficControlPoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TrafficControlPoliciesValue Attribute Value",
				"While creating a TrafficControlPoliciesValue value, an extra attribute value was detected. "+
					"A TrafficControlPoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TrafficControlPoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTrafficControlPoliciesValueUnknown(), diags
	}

	limitCommitOffsetAttribute, ok := attributes["limit_commit_offset"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit_commit_offset is missing from object`)

		return NewTrafficControlPoliciesValueUnknown(), diags
	}

	limitCommitOffsetVal, ok := limitCommitOffsetAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit_commit_offset expected to be basetypes.Int64Value, was: %T`, limitCommitOffsetAttribute))
	}

	maxConsumeRateAttribute, ok := attributes["max_consume_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_consume_rate is missing from object`)

		return NewTrafficControlPoliciesValueUnknown(), diags
	}

	maxConsumeRateVal, ok := maxConsumeRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_consume_rate expected to be basetypes.Int64Value, was: %T`, maxConsumeRateAttribute))
	}

	maxProduceRateAttribute, ok := attributes["max_produce_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_produce_rate is missing from object`)

		return NewTrafficControlPoliciesValueUnknown(), diags
	}

	maxProduceRateVal, ok := maxProduceRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_produce_rate expected to be basetypes.Int64Value, was: %T`, maxProduceRateAttribute))
	}

	if diags.HasError() {
		return NewTrafficControlPoliciesValueUnknown(), diags
	}

	return TrafficControlPoliciesValue{
		LimitCommitOffset: limitCommitOffsetVal,
		MaxConsumeRate:    maxConsumeRateVal,
		MaxProduceRate:    maxProduceRateVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTrafficControlPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TrafficControlPoliciesValue {
	object, diags := NewTrafficControlPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTrafficControlPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TrafficControlPoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTrafficControlPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTrafficControlPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTrafficControlPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTrafficControlPoliciesValueMust(TrafficControlPoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TrafficControlPoliciesType) ValueType(ctx context.Context) attr.Value {
	return TrafficControlPoliciesValue{}
}

var _ basetypes.ObjectValuable = TrafficControlPoliciesValue{}

type TrafficControlPoliciesValue struct {
	LimitCommitOffset basetypes.Int64Value `tfsdk:"limit_commit_offset"`
	MaxConsumeRate    basetypes.Int64Value `tfsdk:"max_consume_rate"`
	MaxProduceRate    basetypes.Int64Value `tfsdk:"max_produce_rate"`
	state             attr.ValueState
}

func (v TrafficControlPoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["limit_commit_offset"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_consume_rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_produce_rate"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LimitCommitOffset.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limit_commit_offset"] = val

		val, err = v.MaxConsumeRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_consume_rate"] = val

		val, err = v.MaxProduceRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_produce_rate"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TrafficControlPoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TrafficControlPoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TrafficControlPoliciesValue) String() string {
	return "TrafficControlPoliciesValue"
}

func (v TrafficControlPoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"limit_commit_offset": basetypes.Int64Type{},
		"max_consume_rate":    basetypes.Int64Type{},
		"max_produce_rate":    basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"limit_commit_offset": v.LimitCommitOffset,
			"max_consume_rate":    v.MaxConsumeRate,
			"max_produce_rate":    v.MaxProduceRate,
		})

	return objVal, diags
}

func (v TrafficControlPoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(TrafficControlPoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LimitCommitOffset.Equal(other.LimitCommitOffset) {
		return false
	}

	if !v.MaxConsumeRate.Equal(other.MaxConsumeRate) {
		return false
	}

	if !v.MaxProduceRate.Equal(other.MaxProduceRate) {
		return false
	}

	return true
}

func (v TrafficControlPoliciesValue) Type(ctx context.Context) attr.Type {
	return TrafficControlPoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TrafficControlPoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"limit_commit_offset": basetypes.Int64Type{},
		"max_consume_rate":    basetypes.Int64Type{},
		"max_produce_rate":    basetypes.Int64Type{},
	}
}
